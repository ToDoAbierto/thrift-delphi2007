(**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *)

unit Thrift.Test;

interface

//{$I uDefine.inc}
{$ifdef CompilerVersion}
{$IF CompilerVersion >= 21}
{$DEFINE CompilerVersion_g21}
{$ELSE}
{$DEFINE CompilerVersion_l21}  
{$IFEND}
{$IF CompilerVersion >= 19} // From Tiburon / Delphi 2009 has support generic collection
{$DEFINE GEN_SUPPORT}
{$DEFINE YES_SCOPEDENUMS}
{$ELSE}
{$DEFINE GEN_NOSUPPORT} //No support Generic
{$DEFINE NO_TStringBuilder}//No Support TStringBuilder
{$DEFINE NO_SCOPEDENUMS}//No Support TStringBuilder
{$IFEND}
{$else}
{$DEFINE GEN_NOSUPPORT}
{$DEFINE NO_TStringBuilder}
{$DEFINE NO_SCOPEDENUMS}
{$DEFINE CompilerVersion_l21}  
{$endif}

uses
  Classes,
  SysUtils,
  uCollections,
  uTypes,
  Thrift,
  Thrift.Utils,
  Thrift.Protocol,
  Thrift.Transport;

const
  cThrift_Test_Option_AnsiStr_Binary = False;
type

//{$SCOPEDENUMS ON}

  TNumberz = (
    ONE = 1,
    TWO = 2,
    THREE = 3,
    FIVE = 5,
    SIX = 6,
    EIGHT = 8
  );

//{$SCOPEDENUMS OFF}

  TUserId = Int64;

  IBonk = interface(IBase)
    function GetMessage: string;
    procedure SetMessage( const Value: string);
    function GetType_: Integer;
    procedure SetType_( const Value: Integer);

    property Message: string read GetMessage write SetMessage;
    property Type_: Integer read GetType_ write SetType_;

    function Get__isset_Message: Boolean;
    function Get__isset_Type_: Boolean;

    property __isset_Message: Boolean read Get__isset_Message;
    property __isset_Type_: Boolean read Get__isset_Type_;
  end;

  TBonkImpl = class(TInterfacedObject, IBase, IBonk)
  private
    FMessage: string;
    FType_: Integer;
    
    F__isset_Message: Boolean;
    F__isset_Type_: Boolean;
    
    function GetMessage: string;
    procedure SetMessage( const Value: string);
    function GetType_: Integer;
    procedure SetType_( const Value: Integer);

    function Get__isset_Message: Boolean;
    function Get__isset_Type_: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Message: string read GetMessage write SetMessage;
    property Type_: Integer read GetType_ write SetType_;

    // isset
    property __isset_Message: Boolean read Get__isset_Message;
    property __isset_Type_: Boolean read Get__isset_Type_;
  end;

  TMapType = IThriftDictionary_V_V;

  IBools = interface(IBase)
    function GetIm_true: Boolean;
    procedure SetIm_true( const Value: Boolean);
    function GetIm_false: Boolean;
    procedure SetIm_false( const Value: Boolean);

    property Im_true: Boolean read GetIm_true write SetIm_true;
    property Im_false: Boolean read GetIm_false write SetIm_false;

    function Get__isset_Im_true: Boolean;
    function Get__isset_Im_false: Boolean;

    property __isset_Im_true: Boolean read Get__isset_Im_true;
    property __isset_Im_false: Boolean read Get__isset_Im_false;
  end;

  TBoolsImpl = class(TInterfacedObject, IBase, IBools)
  private
    FIm_true: Boolean;
    FIm_false: Boolean;
    
    F__isset_Im_true: Boolean;
    F__isset_Im_false: Boolean;
    
    function GetIm_true: Boolean;
    procedure SetIm_true( const Value: Boolean);
    function GetIm_false: Boolean;
    procedure SetIm_false( const Value: Boolean);

    function Get__isset_Im_true: Boolean;
    function Get__isset_Im_false: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Im_true: Boolean read GetIm_true write SetIm_true;
    property Im_false: Boolean read GetIm_false write SetIm_false;

    // isset
    property __isset_Im_true: Boolean read Get__isset_Im_true;
    property __isset_Im_false: Boolean read Get__isset_Im_false;
  end;

  IXtruct = interface(IBase)
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    property String_thing: string read GetString_thing write SetString_thing;
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    function Get__isset_String_thing: Boolean;
    function Get__isset_Byte_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;

    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  TXtructImpl = class(TInterfacedObject, IBase, IXtruct)
  private
    FString_thing: string;
    FByte_thing: ShortInt;
    FI32_thing: Integer;
    FI64_thing: Int64;
    
    F__isset_String_thing: Boolean;
    F__isset_Byte_thing: Boolean;
    F__isset_I32_thing: Boolean;
    F__isset_I64_thing: Boolean;
    
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    function Get__isset_String_thing: Boolean;
    function Get__isset_Byte_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property String_thing: string read GetString_thing write SetString_thing;
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    // isset
    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  IXtruct2 = interface(IBase)
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetStruct_thing: IXtruct;
    procedure SetStruct_thing( const Value: IXtruct);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);

    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;

    function Get__isset_Byte_thing: Boolean;
    function Get__isset_Struct_thing: Boolean;
    function Get__isset_I32_thing: Boolean;

    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
  end;

  TXtruct2Impl = class(TInterfacedObject, IBase, IXtruct2)
  private
    FByte_thing: ShortInt;
    FStruct_thing: IXtruct;
    FI32_thing: Integer;
    
    F__isset_Byte_thing: Boolean;
    F__isset_Struct_thing: Boolean;
    F__isset_I32_thing: Boolean;
    
    function GetByte_thing: ShortInt;
    procedure SetByte_thing( const Value: ShortInt);
    function GetStruct_thing: IXtruct;
    procedure SetStruct_thing( const Value: IXtruct);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);

    function Get__isset_Byte_thing: Boolean;
    function Get__isset_Struct_thing: Boolean;
    function Get__isset_I32_thing: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Byte_thing: ShortInt read GetByte_thing write SetByte_thing;
    property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;

    // isset
    property __isset_Byte_thing: Boolean read Get__isset_Byte_thing;
    property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
  end;

  IXtruct3 = interface(IBase)
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetChanged: Integer;
    procedure SetChanged( const Value: Integer);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    property String_thing: string read GetString_thing write SetString_thing;
    property Changed: Integer read GetChanged write SetChanged;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    function Get__isset_String_thing: Boolean;
    function Get__isset_Changed: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;

    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Changed: Boolean read Get__isset_Changed;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  TXtruct3Impl = class(TInterfacedObject, IBase, IXtruct3)
  private
    FString_thing: string;
    FChanged: Integer;
    FI32_thing: Integer;
    FI64_thing: Int64;
    
    F__isset_String_thing: Boolean;
    F__isset_Changed: Boolean;
    F__isset_I32_thing: Boolean;
    F__isset_I64_thing: Boolean;
    
    function GetString_thing: string;
    procedure SetString_thing( const Value: string);
    function GetChanged: Integer;
    procedure SetChanged( const Value: Integer);
    function GetI32_thing: Integer;
    procedure SetI32_thing( const Value: Integer);
    function GetI64_thing: Int64;
    procedure SetI64_thing( const Value: Int64);

    function Get__isset_String_thing: Boolean;
    function Get__isset_Changed: Boolean;
    function Get__isset_I32_thing: Boolean;
    function Get__isset_I64_thing: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property String_thing: string read GetString_thing write SetString_thing;
    property Changed: Integer read GetChanged write SetChanged;
    property I32_thing: Integer read GetI32_thing write SetI32_thing;
    property I64_thing: Int64 read GetI64_thing write SetI64_thing;

    // isset
    property __isset_String_thing: Boolean read Get__isset_String_thing;
    property __isset_Changed: Boolean read Get__isset_Changed;
    property __isset_I32_thing: Boolean read Get__isset_I32_thing;
    property __isset_I64_thing: Boolean read Get__isset_I64_thing;
  end;

  IInsanity = interface(IBase)
    function GetUserMap: IThriftDictionary_V_V;
    procedure SetUserMap( const Value: IThriftDictionary_V_V);
    function GetXtructs: IThriftList_V;
    procedure SetXtructs( const Value: IThriftList_V);

    property UserMap: IThriftDictionary_V_V read GetUserMap write SetUserMap;
    property Xtructs: IThriftList_V read GetXtructs write SetXtructs;

    function Get__isset_UserMap: Boolean;
    function Get__isset_Xtructs: Boolean;

    property __isset_UserMap: Boolean read Get__isset_UserMap;
    property __isset_Xtructs: Boolean read Get__isset_Xtructs;
  end;

  TInsanityImpl = class(TInterfacedObject, IBase, IInsanity)
  private
    FUserMap: IThriftDictionary_V_V;
    FXtructs: IThriftList_V;
    
    F__isset_UserMap: Boolean;
    F__isset_Xtructs: Boolean;
    
    function GetUserMap: IThriftDictionary_V_V;
    procedure SetUserMap( const Value: IThriftDictionary_V_V);
    function GetXtructs: IThriftList_V;
    procedure SetXtructs( const Value: IThriftList_V);

    function Get__isset_UserMap: Boolean;
    function Get__isset_Xtructs: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property UserMap: IThriftDictionary_V_V read GetUserMap write SetUserMap;
    property Xtructs: IThriftList_V read GetXtructs write SetXtructs;

    // isset
    property __isset_UserMap: Boolean read Get__isset_UserMap;
    property __isset_Xtructs: Boolean read Get__isset_Xtructs;
  end;

  ICrazyNesting = interface(IBase)
    function GetString_field: string;
    procedure SetString_field( const Value: string);
    function GetSet_field: IHashSet_V;
    procedure SetSet_field( const Value: IHashSet_V);
    function GetList_field: IThriftList_V;
    procedure SetList_field( const Value: IThriftList_V);
    function GetBinary_field: TBytes;
    procedure SetBinary_field( const Value: TBytes);

    property String_field: string read GetString_field write SetString_field;
    property Set_field: IHashSet_V read GetSet_field write SetSet_field;
    property List_field: IThriftList_V read GetList_field write SetList_field;
    property Binary_field: TBytes read GetBinary_field write SetBinary_field;

    function Get__isset_String_field: Boolean;
    function Get__isset_Set_field: Boolean;
    function Get__isset_Binary_field: Boolean;

    property __isset_String_field: Boolean read Get__isset_String_field;
    property __isset_Set_field: Boolean read Get__isset_Set_field;
    property __isset_Binary_field: Boolean read Get__isset_Binary_field;
  end;

  TCrazyNestingImpl = class(TInterfacedObject, IBase, ICrazyNesting)
  private
    FString_field: string;
    FSet_field: IHashSet_V;
    FList_field: IThriftList_V;
    FBinary_field: TBytes;
    
    F__isset_String_field: Boolean;
    F__isset_Set_field: Boolean;
    F__isset_Binary_field: Boolean;
    
    function GetString_field: string;
    procedure SetString_field( const Value: string);
    function GetSet_field: IHashSet_V;
    procedure SetSet_field( const Value: IHashSet_V);
    function GetList_field: IThriftList_V;
    procedure SetList_field( const Value: IThriftList_V);
    function GetBinary_field: TBytes;
    procedure SetBinary_field( const Value: TBytes);

    function Get__isset_String_field: Boolean;
    function Get__isset_Set_field: Boolean;
    function Get__isset_Binary_field: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property String_field: string read GetString_field write SetString_field;
    property Set_field: IHashSet_V read GetSet_field write SetSet_field;
    property List_field: IThriftList_V read GetList_field write SetList_field;
    property Binary_field: TBytes read GetBinary_field write SetBinary_field;

    // isset
    property __isset_String_field: Boolean read Get__isset_String_field;
    property __isset_Set_field: Boolean read Get__isset_Set_field;
    property __isset_Binary_field: Boolean read Get__isset_Binary_field;
  end;

  TXception = class(TException)
  public
    type
      IXceptionFactory = interface(IBase)
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetMessage_: string;
        procedure SetMessage_( const Value: string);

        // Create Exception Object
        function CreateException: TXception;

        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Message_: string read GetMessage_ write SetMessage_;

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Message_: Boolean;

        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Message_: Boolean read Get__isset_Message_;
      end;

      TXceptionFactoryImpl = class(TInterfacedObject, IBase, IXceptionFactory)
      private
        FErrorCode: Integer;
        FMessage_: string;
        
        F__isset_ErrorCode: Boolean;
        F__isset_Message_: Boolean;
        
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetMessage_: string;
        procedure SetMessage_( const Value: string);

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Message_: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Create Exception Object
        function CreateException: TXception;

        // Properties
        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Message_: string read GetMessage_ write SetMessage_;

        // isset
        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Message_: Boolean read Get__isset_Message_;
      end;

  private
    FXceptionFactory :IXceptionFactory;

    FErrorCode: Integer;
    FMessage_: string;
    
    F__isset_ErrorCode: Boolean;
    F__isset_Message_: Boolean;
    
    function GetErrorCode: Integer;
    procedure SetErrorCode( const Value: Integer);
    function GetMessage_: string;
    procedure SetMessage_( const Value: string);

    function Get__isset_ErrorCode: Boolean;
    function Get__isset_Message_: Boolean;
  public
    constructor Create; overload;
    constructor Create( AErrorCode: Integer; const AMessage: string); overload;
    destructor Destroy; override;

    function ToString: string; {override}

    // Exception Factory
    property XceptionFactory: IXceptionFactory read FXceptionFactory write FXceptionFactory;

    // Properties
    property ErrorCode: Integer read GetErrorCode write SetErrorCode;
    property Message_: string read GetMessage_ write SetMessage_;

    // isset
    property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
    property __isset_Message_: Boolean read Get__isset_Message_;
  end;

  TXception2 = class(TException)
  public
    type
      IXception2Factory = interface(IBase)
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetStruct_thing: IXtruct;
        procedure SetStruct_thing( const Value: IXtruct);

        // Create Exception Object
        function CreateException: TXception2;

        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Struct_thing: Boolean;

        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
      end;

      TXception2FactoryImpl = class(TInterfacedObject, IBase, IXception2Factory)
      private
        FErrorCode: Integer;
        FStruct_thing: IXtruct;
        
        F__isset_ErrorCode: Boolean;
        F__isset_Struct_thing: Boolean;
        
        function GetErrorCode: Integer;
        procedure SetErrorCode( const Value: Integer);
        function GetStruct_thing: IXtruct;
        procedure SetStruct_thing( const Value: IXtruct);

        function Get__isset_ErrorCode: Boolean;
        function Get__isset_Struct_thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Create Exception Object
        function CreateException: TXception2;

        // Properties
        property ErrorCode: Integer read GetErrorCode write SetErrorCode;
        property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;

        // isset
        property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
        property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
      end;

  private
    FXception2Factory :IXception2Factory;

    FErrorCode: Integer;
    FStruct_thing: IXtruct;
    
    F__isset_ErrorCode: Boolean;
    F__isset_Struct_thing: Boolean;
    
    function GetErrorCode: Integer;
    procedure SetErrorCode( const Value: Integer);
    function GetStruct_thing: IXtruct;
    procedure SetStruct_thing( const Value: IXtruct);

    function Get__isset_ErrorCode: Boolean;
    function Get__isset_Struct_thing: Boolean;
  public
    constructor Create; overload;
    constructor Create( AErrorCode: Integer; const AStruct_thing: IXtruct); overload;
    destructor Destroy; override;

    function ToString: string; {override}

    // Exception Factory
    property Xception2Factory: IXception2Factory read FXception2Factory write FXception2Factory;

    // Properties
    property ErrorCode: Integer read GetErrorCode write SetErrorCode;
    property Struct_thing: IXtruct read GetStruct_thing write SetStruct_thing;

    // isset
    property __isset_ErrorCode: Boolean read Get__isset_ErrorCode;
    property __isset_Struct_thing: Boolean read Get__isset_Struct_thing;
  end;

  IEmptyStruct = interface(IBase)
  end;

  TEmptyStructImpl = class(TInterfacedObject, IBase, IEmptyStruct)
  private
    
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);
  end;

  IOneField = interface(IBase)
    function GetField: IEmptyStruct;
    procedure SetField( const Value: IEmptyStruct);

    property Field: IEmptyStruct read GetField write SetField;

    function Get__isset_Field: Boolean;

    property __isset_Field: Boolean read Get__isset_Field;
  end;

  TOneFieldImpl = class(TInterfacedObject, IBase, IOneField)
  private
    FField: IEmptyStruct;
    
    F__isset_Field: Boolean;
    
    function GetField: IEmptyStruct;
    procedure SetField( const Value: IEmptyStruct);

    function Get__isset_Field: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Field: IEmptyStruct read GetField write SetField;

    // isset
    property __isset_Field: Boolean read Get__isset_Field;
  end;

  IVersioningTestV1 = interface(IBase)
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetOld_string: string;
    procedure SetOld_string( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Old_string: string read GetOld_string write SetOld_string;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Old_string: Boolean;
    function Get__isset_End_in_both: Boolean;

    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Old_string: Boolean read Get__isset_Old_string;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  TVersioningTestV1Impl = class(TInterfacedObject, IBase, IVersioningTestV1)
  private
    FBegin_in_both: Integer;
    FOld_string: string;
    FEnd_in_both: Integer;
    
    F__isset_Begin_in_both: Boolean;
    F__isset_Old_string: Boolean;
    F__isset_End_in_both: Boolean;
    
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetOld_string: string;
    procedure SetOld_string( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Old_string: Boolean;
    function Get__isset_End_in_both: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Old_string: string read GetOld_string write SetOld_string;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    // isset
    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Old_string: Boolean read Get__isset_Old_string;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  IVersioningTestV2 = interface(IBase)
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetNewint: Integer;
    procedure SetNewint( const Value: Integer);
    function GetNewbyte: ShortInt;
    procedure SetNewbyte( const Value: ShortInt);
    function GetNewshort: SmallInt;
    procedure SetNewshort( const Value: SmallInt);
    function GetNewlong: Int64;
    procedure SetNewlong( const Value: Int64);
    function GetNewdouble: Double;
    procedure SetNewdouble( const Value: Double);
    function GetNewstruct: IBonk;
    procedure SetNewstruct( const Value: IBonk);
    function GetNewlist: IThriftList_V;
    procedure SetNewlist( const Value: IThriftList_V);
    function GetNewset: IHashSet_V;
    procedure SetNewset( const Value: IHashSet_V);
    function GetNewmap: IThriftDictionary_V_V;
    procedure SetNewmap( const Value: IThriftDictionary_V_V);
    function GetNewstring: string;
    procedure SetNewstring( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Newint: Integer read GetNewint write SetNewint;
    property Newbyte: ShortInt read GetNewbyte write SetNewbyte;
    property Newshort: SmallInt read GetNewshort write SetNewshort;
    property Newlong: Int64 read GetNewlong write SetNewlong;
    property Newdouble: Double read GetNewdouble write SetNewdouble;
    property Newstruct: IBonk read GetNewstruct write SetNewstruct;
    property Newlist: IThriftList_V read GetNewlist write SetNewlist;
    property Newset: IHashSet_V read GetNewset write SetNewset;
    property Newmap: IThriftDictionary_V_V read GetNewmap write SetNewmap;
    property Newstring: string read GetNewstring write SetNewstring;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Newint: Boolean;
    function Get__isset_Newbyte: Boolean;
    function Get__isset_Newshort: Boolean;
    function Get__isset_Newlong: Boolean;
    function Get__isset_Newdouble: Boolean;
    function Get__isset_Newstruct: Boolean;
    function Get__isset_Newlist: Boolean;
    function Get__isset_Newset: Boolean;
    function Get__isset_Newmap: Boolean;
    function Get__isset_Newstring: Boolean;
    function Get__isset_End_in_both: Boolean;

    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Newint: Boolean read Get__isset_Newint;
    property __isset_Newbyte: Boolean read Get__isset_Newbyte;
    property __isset_Newshort: Boolean read Get__isset_Newshort;
    property __isset_Newlong: Boolean read Get__isset_Newlong;
    property __isset_Newdouble: Boolean read Get__isset_Newdouble;
    property __isset_Newstruct: Boolean read Get__isset_Newstruct;
    property __isset_Newlist: Boolean read Get__isset_Newlist;
    property __isset_Newset: Boolean read Get__isset_Newset;
    property __isset_Newmap: Boolean read Get__isset_Newmap;
    property __isset_Newstring: Boolean read Get__isset_Newstring;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  TVersioningTestV2Impl = class(TInterfacedObject, IBase, IVersioningTestV2)
  private
    FBegin_in_both: Integer;
    FNewint: Integer;
    FNewbyte: ShortInt;
    FNewshort: SmallInt;
    FNewlong: Int64;
    FNewdouble: Double;
    FNewstruct: IBonk;
    FNewlist: IThriftList_V;
    FNewset: IHashSet_V;
    FNewmap: IThriftDictionary_V_V;
    FNewstring: string;
    FEnd_in_both: Integer;
    
    F__isset_Begin_in_both: Boolean;
    F__isset_Newint: Boolean;
    F__isset_Newbyte: Boolean;
    F__isset_Newshort: Boolean;
    F__isset_Newlong: Boolean;
    F__isset_Newdouble: Boolean;
    F__isset_Newstruct: Boolean;
    F__isset_Newlist: Boolean;
    F__isset_Newset: Boolean;
    F__isset_Newmap: Boolean;
    F__isset_Newstring: Boolean;
    F__isset_End_in_both: Boolean;
    
    function GetBegin_in_both: Integer;
    procedure SetBegin_in_both( const Value: Integer);
    function GetNewint: Integer;
    procedure SetNewint( const Value: Integer);
    function GetNewbyte: ShortInt;
    procedure SetNewbyte( const Value: ShortInt);
    function GetNewshort: SmallInt;
    procedure SetNewshort( const Value: SmallInt);
    function GetNewlong: Int64;
    procedure SetNewlong( const Value: Int64);
    function GetNewdouble: Double;
    procedure SetNewdouble( const Value: Double);
    function GetNewstruct: IBonk;
    procedure SetNewstruct( const Value: IBonk);
    function GetNewlist: IThriftList_V;
    procedure SetNewlist( const Value: IThriftList_V);
    function GetNewset: IHashSet_V;
    procedure SetNewset( const Value: IHashSet_V);
    function GetNewmap: IThriftDictionary_V_V;
    procedure SetNewmap( const Value: IThriftDictionary_V_V);
    function GetNewstring: string;
    procedure SetNewstring( const Value: string);
    function GetEnd_in_both: Integer;
    procedure SetEnd_in_both( const Value: Integer);

    function Get__isset_Begin_in_both: Boolean;
    function Get__isset_Newint: Boolean;
    function Get__isset_Newbyte: Boolean;
    function Get__isset_Newshort: Boolean;
    function Get__isset_Newlong: Boolean;
    function Get__isset_Newdouble: Boolean;
    function Get__isset_Newstruct: Boolean;
    function Get__isset_Newlist: Boolean;
    function Get__isset_Newset: Boolean;
    function Get__isset_Newmap: Boolean;
    function Get__isset_Newstring: Boolean;
    function Get__isset_End_in_both: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Begin_in_both: Integer read GetBegin_in_both write SetBegin_in_both;
    property Newint: Integer read GetNewint write SetNewint;
    property Newbyte: ShortInt read GetNewbyte write SetNewbyte;
    property Newshort: SmallInt read GetNewshort write SetNewshort;
    property Newlong: Int64 read GetNewlong write SetNewlong;
    property Newdouble: Double read GetNewdouble write SetNewdouble;
    property Newstruct: IBonk read GetNewstruct write SetNewstruct;
    property Newlist: IThriftList_V read GetNewlist write SetNewlist;
    property Newset: IHashSet_V read GetNewset write SetNewset;
    property Newmap: IThriftDictionary_V_V read GetNewmap write SetNewmap;
    property Newstring: string read GetNewstring write SetNewstring;
    property End_in_both: Integer read GetEnd_in_both write SetEnd_in_both;

    // isset
    property __isset_Begin_in_both: Boolean read Get__isset_Begin_in_both;
    property __isset_Newint: Boolean read Get__isset_Newint;
    property __isset_Newbyte: Boolean read Get__isset_Newbyte;
    property __isset_Newshort: Boolean read Get__isset_Newshort;
    property __isset_Newlong: Boolean read Get__isset_Newlong;
    property __isset_Newdouble: Boolean read Get__isset_Newdouble;
    property __isset_Newstruct: Boolean read Get__isset_Newstruct;
    property __isset_Newlist: Boolean read Get__isset_Newlist;
    property __isset_Newset: Boolean read Get__isset_Newset;
    property __isset_Newmap: Boolean read Get__isset_Newmap;
    property __isset_Newstring: Boolean read Get__isset_Newstring;
    property __isset_End_in_both: Boolean read Get__isset_End_in_both;
  end;

  IListTypeVersioningV1 = interface(IBase)
    function GetMyints: IThriftList_V;
    procedure SetMyints( const Value: IThriftList_V);
    function GetHello: string;
    procedure SetHello( const Value: string);

    property Myints: IThriftList_V read GetMyints write SetMyints;
    property Hello: string read GetHello write SetHello;

    function Get__isset_Myints: Boolean;
    function Get__isset_Hello: Boolean;

    property __isset_Myints: Boolean read Get__isset_Myints;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  TListTypeVersioningV1Impl = class(TInterfacedObject, IBase, IListTypeVersioningV1)
  private
    FMyints: IThriftList_V;
    FHello: string;
    
    F__isset_Myints: Boolean;
    F__isset_Hello: Boolean;
    
    function GetMyints: IThriftList_V;
    procedure SetMyints( const Value: IThriftList_V);
    function GetHello: string;
    procedure SetHello( const Value: string);

    function Get__isset_Myints: Boolean;
    function Get__isset_Hello: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Myints: IThriftList_V read GetMyints write SetMyints;
    property Hello: string read GetHello write SetHello;

    // isset
    property __isset_Myints: Boolean read Get__isset_Myints;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  IListTypeVersioningV2 = interface(IBase)
    function GetStrings: IThriftList_V;
    procedure SetStrings( const Value: IThriftList_V);
    function GetHello: string;
    procedure SetHello( const Value: string);

    property Strings: IThriftList_V read GetStrings write SetStrings;
    property Hello: string read GetHello write SetHello;

    function Get__isset_Strings: Boolean;
    function Get__isset_Hello: Boolean;

    property __isset_Strings: Boolean read Get__isset_Strings;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  TListTypeVersioningV2Impl = class(TInterfacedObject, IBase, IListTypeVersioningV2)
  private
    FStrings: IThriftList_V;
    FHello: string;
    
    F__isset_Strings: Boolean;
    F__isset_Hello: Boolean;
    
    function GetStrings: IThriftList_V;
    procedure SetStrings( const Value: IThriftList_V);
    function GetHello: string;
    procedure SetHello( const Value: string);

    function Get__isset_Strings: Boolean;
    function Get__isset_Hello: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Strings: IThriftList_V read GetStrings write SetStrings;
    property Hello: string read GetHello write SetHello;

    // isset
    property __isset_Strings: Boolean read Get__isset_Strings;
    property __isset_Hello: Boolean read Get__isset_Hello;
  end;

  IGuessProtocolStruct = interface(IBase)
    function GetMap_field: IThriftDictionary_V_V;
    procedure SetMap_field( const Value: IThriftDictionary_V_V);

    property Map_field: IThriftDictionary_V_V read GetMap_field write SetMap_field;

    function Get__isset_Map_field: Boolean;

    property __isset_Map_field: Boolean read Get__isset_Map_field;
  end;

  TGuessProtocolStructImpl = class(TInterfacedObject, IBase, IGuessProtocolStruct)
  private
    FMap_field: IThriftDictionary_V_V;
    
    F__isset_Map_field: Boolean;
    
    function GetMap_field: IThriftDictionary_V_V;
    procedure SetMap_field( const Value: IThriftDictionary_V_V);

    function Get__isset_Map_field: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Map_field: IThriftDictionary_V_V read GetMap_field write SetMap_field;

    // isset
    property __isset_Map_field: Boolean read Get__isset_Map_field;
  end;

  ILargeDeltas = interface(IBase)
    function GetB1: IBools;
    procedure SetB1( const Value: IBools);
    function GetB10: IBools;
    procedure SetB10( const Value: IBools);
    function GetB100: IBools;
    procedure SetB100( const Value: IBools);
    function GetCheck_true: Boolean;
    procedure SetCheck_true( const Value: Boolean);
    function GetB1000: IBools;
    procedure SetB1000( const Value: IBools);
    function GetCheck_false: Boolean;
    procedure SetCheck_false( const Value: Boolean);
    function GetVertwo2000: IVersioningTestV2;
    procedure SetVertwo2000( const Value: IVersioningTestV2);
    function GetA_set2500: IHashSet_V;
    procedure SetA_set2500( const Value: IHashSet_V);
    function GetVertwo3000: IVersioningTestV2;
    procedure SetVertwo3000( const Value: IVersioningTestV2);
    function GetBig_numbers: IThriftList_V;
    procedure SetBig_numbers( const Value: IThriftList_V);

    property B1: IBools read GetB1 write SetB1;
    property B10: IBools read GetB10 write SetB10;
    property B100: IBools read GetB100 write SetB100;
    property Check_true: Boolean read GetCheck_true write SetCheck_true;
    property B1000: IBools read GetB1000 write SetB1000;
    property Check_false: Boolean read GetCheck_false write SetCheck_false;
    property Vertwo2000: IVersioningTestV2 read GetVertwo2000 write SetVertwo2000;
    property A_set2500: IHashSet_V read GetA_set2500 write SetA_set2500;
    property Vertwo3000: IVersioningTestV2 read GetVertwo3000 write SetVertwo3000;
    property Big_numbers: IThriftList_V read GetBig_numbers write SetBig_numbers;

    function Get__isset_B1: Boolean;
    function Get__isset_B10: Boolean;
    function Get__isset_B100: Boolean;
    function Get__isset_Check_true: Boolean;
    function Get__isset_B1000: Boolean;
    function Get__isset_Check_false: Boolean;
    function Get__isset_Vertwo2000: Boolean;
    function Get__isset_A_set2500: Boolean;
    function Get__isset_Vertwo3000: Boolean;
    function Get__isset_Big_numbers: Boolean;

    property __isset_B1: Boolean read Get__isset_B1;
    property __isset_B10: Boolean read Get__isset_B10;
    property __isset_B100: Boolean read Get__isset_B100;
    property __isset_Check_true: Boolean read Get__isset_Check_true;
    property __isset_B1000: Boolean read Get__isset_B1000;
    property __isset_Check_false: Boolean read Get__isset_Check_false;
    property __isset_Vertwo2000: Boolean read Get__isset_Vertwo2000;
    property __isset_A_set2500: Boolean read Get__isset_A_set2500;
    property __isset_Vertwo3000: Boolean read Get__isset_Vertwo3000;
    property __isset_Big_numbers: Boolean read Get__isset_Big_numbers;
  end;

  TLargeDeltasImpl = class(TInterfacedObject, IBase, ILargeDeltas)
  private
    FB1: IBools;
    FB10: IBools;
    FB100: IBools;
    FCheck_true: Boolean;
    FB1000: IBools;
    FCheck_false: Boolean;
    FVertwo2000: IVersioningTestV2;
    FA_set2500: IHashSet_V;
    FVertwo3000: IVersioningTestV2;
    FBig_numbers: IThriftList_V;
    
    F__isset_B1: Boolean;
    F__isset_B10: Boolean;
    F__isset_B100: Boolean;
    F__isset_Check_true: Boolean;
    F__isset_B1000: Boolean;
    F__isset_Check_false: Boolean;
    F__isset_Vertwo2000: Boolean;
    F__isset_A_set2500: Boolean;
    F__isset_Vertwo3000: Boolean;
    F__isset_Big_numbers: Boolean;
    
    function GetB1: IBools;
    procedure SetB1( const Value: IBools);
    function GetB10: IBools;
    procedure SetB10( const Value: IBools);
    function GetB100: IBools;
    procedure SetB100( const Value: IBools);
    function GetCheck_true: Boolean;
    procedure SetCheck_true( const Value: Boolean);
    function GetB1000: IBools;
    procedure SetB1000( const Value: IBools);
    function GetCheck_false: Boolean;
    procedure SetCheck_false( const Value: Boolean);
    function GetVertwo2000: IVersioningTestV2;
    procedure SetVertwo2000( const Value: IVersioningTestV2);
    function GetA_set2500: IHashSet_V;
    procedure SetA_set2500( const Value: IHashSet_V);
    function GetVertwo3000: IVersioningTestV2;
    procedure SetVertwo3000( const Value: IVersioningTestV2);
    function GetBig_numbers: IThriftList_V;
    procedure SetBig_numbers( const Value: IThriftList_V);

    function Get__isset_B1: Boolean;
    function Get__isset_B10: Boolean;
    function Get__isset_B100: Boolean;
    function Get__isset_Check_true: Boolean;
    function Get__isset_B1000: Boolean;
    function Get__isset_Check_false: Boolean;
    function Get__isset_Vertwo2000: Boolean;
    function Get__isset_A_set2500: Boolean;
    function Get__isset_Vertwo3000: Boolean;
    function Get__isset_Big_numbers: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property B1: IBools read GetB1 write SetB1;
    property B10: IBools read GetB10 write SetB10;
    property B100: IBools read GetB100 write SetB100;
    property Check_true: Boolean read GetCheck_true write SetCheck_true;
    property B1000: IBools read GetB1000 write SetB1000;
    property Check_false: Boolean read GetCheck_false write SetCheck_false;
    property Vertwo2000: IVersioningTestV2 read GetVertwo2000 write SetVertwo2000;
    property A_set2500: IHashSet_V read GetA_set2500 write SetA_set2500;
    property Vertwo3000: IVersioningTestV2 read GetVertwo3000 write SetVertwo3000;
    property Big_numbers: IThriftList_V read GetBig_numbers write SetBig_numbers;

    // isset
    property __isset_B1: Boolean read Get__isset_B1;
    property __isset_B10: Boolean read Get__isset_B10;
    property __isset_B100: Boolean read Get__isset_B100;
    property __isset_Check_true: Boolean read Get__isset_Check_true;
    property __isset_B1000: Boolean read Get__isset_B1000;
    property __isset_Check_false: Boolean read Get__isset_Check_false;
    property __isset_Vertwo2000: Boolean read Get__isset_Vertwo2000;
    property __isset_A_set2500: Boolean read Get__isset_A_set2500;
    property __isset_Vertwo3000: Boolean read Get__isset_Vertwo3000;
    property __isset_Big_numbers: Boolean read Get__isset_Big_numbers;
  end;

  INestedListsI32x2 = interface(IBase)
    function GetIntegerlist: IThriftList_V;
    procedure SetIntegerlist( const Value: IThriftList_V);

    property Integerlist: IThriftList_V read GetIntegerlist write SetIntegerlist;

    function Get__isset_Integerlist: Boolean;

    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  TNestedListsI32x2Impl = class(TInterfacedObject, IBase, INestedListsI32x2)
  private
    FIntegerlist: IThriftList_V;
    
    F__isset_Integerlist: Boolean;
    
    function GetIntegerlist: IThriftList_V;
    procedure SetIntegerlist( const Value: IThriftList_V);

    function Get__isset_Integerlist: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Integerlist: IThriftList_V read GetIntegerlist write SetIntegerlist;

    // isset
    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  INestedListsI32x3 = interface(IBase)
    function GetIntegerlist: IThriftList_V;
    procedure SetIntegerlist( const Value: IThriftList_V);

    property Integerlist: IThriftList_V read GetIntegerlist write SetIntegerlist;

    function Get__isset_Integerlist: Boolean;

    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  TNestedListsI32x3Impl = class(TInterfacedObject, IBase, INestedListsI32x3)
  private
    FIntegerlist: IThriftList_V;
    
    F__isset_Integerlist: Boolean;
    
    function GetIntegerlist: IThriftList_V;
    procedure SetIntegerlist( const Value: IThriftList_V);

    function Get__isset_Integerlist: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Integerlist: IThriftList_V read GetIntegerlist write SetIntegerlist;

    // isset
    property __isset_Integerlist: Boolean read Get__isset_Integerlist;
  end;

  INestedMixedx2 = interface(IBase)
    function GetInt_set_list: IThriftList_V;
    procedure SetInt_set_list( const Value: IThriftList_V);
    function GetMap_int_strset: IThriftDictionary_V_V;
    procedure SetMap_int_strset( const Value: IThriftDictionary_V_V);
    function GetMap_int_strset_list: IThriftList_V;
    procedure SetMap_int_strset_list( const Value: IThriftList_V);

    property Int_set_list: IThriftList_V read GetInt_set_list write SetInt_set_list;
    property Map_int_strset: IThriftDictionary_V_V read GetMap_int_strset write SetMap_int_strset;
    property Map_int_strset_list: IThriftList_V read GetMap_int_strset_list write SetMap_int_strset_list;

    function Get__isset_Int_set_list: Boolean;
    function Get__isset_Map_int_strset: Boolean;
    function Get__isset_Map_int_strset_list: Boolean;

    property __isset_Int_set_list: Boolean read Get__isset_Int_set_list;
    property __isset_Map_int_strset: Boolean read Get__isset_Map_int_strset;
    property __isset_Map_int_strset_list: Boolean read Get__isset_Map_int_strset_list;
  end;

  TNestedMixedx2Impl = class(TInterfacedObject, IBase, INestedMixedx2)
  private
    FInt_set_list: IThriftList_V;
    FMap_int_strset: IThriftDictionary_V_V;
    FMap_int_strset_list: IThriftList_V;
    
    F__isset_Int_set_list: Boolean;
    F__isset_Map_int_strset: Boolean;
    F__isset_Map_int_strset_list: Boolean;
    
    function GetInt_set_list: IThriftList_V;
    procedure SetInt_set_list( const Value: IThriftList_V);
    function GetMap_int_strset: IThriftDictionary_V_V;
    procedure SetMap_int_strset( const Value: IThriftDictionary_V_V);
    function GetMap_int_strset_list: IThriftList_V;
    procedure SetMap_int_strset_list( const Value: IThriftList_V);

    function Get__isset_Int_set_list: Boolean;
    function Get__isset_Map_int_strset: Boolean;
    function Get__isset_Map_int_strset_list: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Int_set_list: IThriftList_V read GetInt_set_list write SetInt_set_list;
    property Map_int_strset: IThriftDictionary_V_V read GetMap_int_strset write SetMap_int_strset;
    property Map_int_strset_list: IThriftList_V read GetMap_int_strset_list write SetMap_int_strset_list;

    // isset
    property __isset_Int_set_list: Boolean read Get__isset_Int_set_list;
    property __isset_Map_int_strset: Boolean read Get__isset_Map_int_strset;
    property __isset_Map_int_strset_list: Boolean read Get__isset_Map_int_strset_list;
  end;

  IListBonks = interface(IBase)
    function GetBonk: IThriftList_V;
    procedure SetBonk( const Value: IThriftList_V);

    property Bonk: IThriftList_V read GetBonk write SetBonk;

    function Get__isset_Bonk: Boolean;

    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  TListBonksImpl = class(TInterfacedObject, IBase, IListBonks)
  private
    FBonk: IThriftList_V;
    
    F__isset_Bonk: Boolean;
    
    function GetBonk: IThriftList_V;
    procedure SetBonk( const Value: IThriftList_V);

    function Get__isset_Bonk: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Bonk: IThriftList_V read GetBonk write SetBonk;

    // isset
    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  INestedListsBonk = interface(IBase)
    function GetBonk: IThriftList_V;
    procedure SetBonk( const Value: IThriftList_V);

    property Bonk: IThriftList_V read GetBonk write SetBonk;

    function Get__isset_Bonk: Boolean;

    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  TNestedListsBonkImpl = class(TInterfacedObject, IBase, INestedListsBonk)
  private
    FBonk: IThriftList_V;
    
    F__isset_Bonk: Boolean;
    
    function GetBonk: IThriftList_V;
    procedure SetBonk( const Value: IThriftList_V);

    function Get__isset_Bonk: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Bonk: IThriftList_V read GetBonk write SetBonk;

    // isset
    property __isset_Bonk: Boolean read Get__isset_Bonk;
  end;

  IBoolTest = interface(IBase)
    function GetB: Boolean;
    procedure SetB( const Value: Boolean);
    function GetS: string;
    procedure SetS( const Value: string);

    property B: Boolean read GetB write SetB;
    property S: string read GetS write SetS;

    function Get__isset_B: Boolean;
    function Get__isset_S: Boolean;

    property __isset_B: Boolean read Get__isset_B;
    property __isset_S: Boolean read Get__isset_S;
  end;

  TBoolTestImpl = class(TInterfacedObject, IBase, IBoolTest)
  private
    FB: Boolean;
    FS: string;
    
    F__isset_B: Boolean;
    F__isset_S: Boolean;
    
    function GetB: Boolean;
    procedure SetB( const Value: Boolean);
    function GetS: string;
    procedure SetS( const Value: string);

    function Get__isset_B: Boolean;
    function Get__isset_S: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property B: Boolean read GetB write SetB;
    property S: string read GetS write SetS;

    // isset
    property __isset_B: Boolean read Get__isset_B;
    property __isset_S: Boolean read Get__isset_S;
  end;

  IStructA = interface(IBase)
    function GetS: string;
    procedure SetS( const Value: string);

    property S: string read GetS write SetS;


  end;

  TStructAImpl = class(TInterfacedObject, IBase, IStructA)
  private
    FS: string;
    
    
    function GetS: string;
    procedure SetS( const Value: string);

  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property S: string read GetS write SetS;

    // isset
  end;

  IStructB = interface(IBase)
    function GetAa: IStructA;
    procedure SetAa( const Value: IStructA);
    function GetAb: IStructA;
    procedure SetAb( const Value: IStructA);

    property Aa: IStructA read GetAa write SetAa;
    property Ab: IStructA read GetAb write SetAb;

    function Get__isset_Aa: Boolean;

    property __isset_Aa: Boolean read Get__isset_Aa;
  end;

  TStructBImpl = class(TInterfacedObject, IBase, IStructB)
  private
    FAa: IStructA;
    FAb: IStructA;
    
    F__isset_Aa: Boolean;
    
    function GetAa: IStructA;
    procedure SetAa( const Value: IStructA);
    function GetAb: IStructA;
    procedure SetAb( const Value: IStructA);

    function Get__isset_Aa: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; {override}

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Aa: IStructA read GetAa write SetAa;
    property Ab: IStructA read GetAb write SetAb;

    // isset
    property __isset_Aa: Boolean read Get__isset_Aa;
  end;

  TThriftTest = class
  public
    type
      Iface = interface
        procedure testVoid();
        function testString(const thing: string): string;
        function testByte(thing: ShortInt): ShortInt;
        function testI32(thing: Integer): Integer;
        function testI64(const thing: Int64): Int64;
        function testDouble(const thing: Double): Double;
        function testStruct(const thing: IXtruct): IXtruct;
        function testNest(const thing: IXtruct2): IXtruct2;
        function testMap(const thing: IThriftDictionary_V_V): IThriftDictionary_V_V;
        function testStringMap(const thing: IThriftDictionary_V_V): IThriftDictionary_V_V;
        function testSet(const thing: IHashSet_V): IHashSet_V;
        function testList(const thing: IThriftList_V): IThriftList_V;
        function testEnum(thing: TNumberz): TNumberz;
        function testTypedef(const thing: TUserId): TUserId;
        function testMapMap(hello: Integer): IThriftDictionary_V_V;
        function testInsanity(const argument: IInsanity): IThriftDictionary_V_V;
        function testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary_V_V; arg4: TNumberz; const arg5: TUserId): IXtruct;
        procedure testException(const arg: string);
        function testMultiException(const arg0: string; const arg1: string): IXtruct;
        procedure testOneway(secondsToSleep: Integer);
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        procedure testVoid();
        function testString(const thing: string): string;
        function testByte(thing: ShortInt): ShortInt;
        function testI32(thing: Integer): Integer;
        function testI64(const thing: Int64): Int64;
        function testDouble(const thing: Double): Double;
        function testStruct(const thing: IXtruct): IXtruct;
        function testNest(const thing: IXtruct2): IXtruct2;
        function testMap(const thing: IThriftDictionary_V_V): IThriftDictionary_V_V;
        function testStringMap(const thing: IThriftDictionary_V_V): IThriftDictionary_V_V;
        function testSet(const thing: IHashSet_V): IHashSet_V;
        function testList(const thing: IThriftList_V): IThriftList_V;
        function testEnum(thing: TNumberz): TNumberz;
        function testTypedef(const thing: TUserId): TUserId;
        function testMapMap(hello: Integer): IThriftDictionary_V_V;
        function testInsanity(const argument: IInsanity): IThriftDictionary_V_V;
        function testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary_V_V; arg4: TNumberz; const arg5: TUserId): IXtruct;
        procedure testException(const arg: string);
        function testMultiException(const arg0: string; const arg1: string): IXtruct;
        procedure testOneway(secondsToSleep: Integer);
      public
        procedure send_testVoid();
        procedure recv_testVoid();
        procedure send_testString(const thing: string);
        function recv_testString(): string;
        procedure send_testByte(thing: ShortInt);
        function recv_testByte(): ShortInt;
        procedure send_testI32(thing: Integer);
        function recv_testI32(): Integer;
        procedure send_testI64(const thing: Int64);
        function recv_testI64(): Int64;
        procedure send_testDouble(const thing: Double);
        function recv_testDouble(): Double;
        procedure send_testStruct(const thing: IXtruct);
        function recv_testStruct(): IXtruct;
        procedure send_testNest(const thing: IXtruct2);
        function recv_testNest(): IXtruct2;
        procedure send_testMap(const thing: IThriftDictionary_V_V);
        function recv_testMap(): IThriftDictionary_V_V;
        procedure send_testStringMap(const thing: IThriftDictionary_V_V);
        function recv_testStringMap(): IThriftDictionary_V_V;
        procedure send_testSet(const thing: IHashSet_V);
        function recv_testSet(): IHashSet_V;
        procedure send_testList(const thing: IThriftList_V);
        function recv_testList(): IThriftList_V;
        procedure send_testEnum(thing: TNumberz);
        function recv_testEnum(): TNumberz;
        procedure send_testTypedef(const thing: TUserId);
        function recv_testTypedef(): TUserId;
        procedure send_testMapMap(hello: Integer);
        function recv_testMapMap(): IThriftDictionary_V_V;
        procedure send_testInsanity(const argument: IInsanity);
        function recv_testInsanity(): IThriftDictionary_V_V;
        procedure send_testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary_V_V; arg4: TNumberz; const arg5: TUserId);
        function recv_testMulti(): IXtruct;
        procedure send_testException(const arg: string);
        procedure recv_testException();
        procedure send_testMultiException(const arg0: string; const arg1: string);
        function recv_testMultiException(): IXtruct;
        procedure send_testOneway(secondsToSleep: Integer);
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = {reference to }procedure( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface) of object;
      protected
        processMap_: IThriftDictionary_V_V;{IThriftDictionary<string, TProcessFunction>;}
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
        procedure testVoid_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testString_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testByte_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testI32_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testI64_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testDouble_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testStruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testNest_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testStringMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testSet_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testList_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testEnum_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testTypedef_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMapMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testInsanity_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMulti_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testMultiException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
        procedure testOneway_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
      end;

      ITestVoid_args = interface(IBase)
      end;

      TTestVoid_argsImpl = class(TInterfacedObject, IBase, ITestVoid_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      ITestVoid_result = interface(IBase)
      end;

      TTestVoid_resultImpl = class(TInterfacedObject, IBase, ITestVoid_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      ITestString_args = interface(IBase)
        function GetThing: string;
        procedure SetThing( const Value: string);

        property Thing: string read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestString_argsImpl = class(TInterfacedObject, IBase, ITestString_args)
      private
        FThing: string;
        
        F__isset_Thing: Boolean;
        
        function GetThing: string;
        procedure SetThing( const Value: string);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: string read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestString_result = interface(IBase)
        function GetSuccess: string;
        procedure SetSuccess( const Value: string);

        property Success: string read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestString_resultImpl = class(TInterfacedObject, IBase, ITestString_result)
      private
        FSuccess: string;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: string;
        procedure SetSuccess( const Value: string);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: string read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestByte_args = interface(IBase)
        function GetThing: ShortInt;
        procedure SetThing( const Value: ShortInt);

        property Thing: ShortInt read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestByte_argsImpl = class(TInterfacedObject, IBase, ITestByte_args)
      private
        FThing: ShortInt;
        
        F__isset_Thing: Boolean;
        
        function GetThing: ShortInt;
        procedure SetThing( const Value: ShortInt);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: ShortInt read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestByte_result = interface(IBase)
        function GetSuccess: ShortInt;
        procedure SetSuccess( const Value: ShortInt);

        property Success: ShortInt read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestByte_resultImpl = class(TInterfacedObject, IBase, ITestByte_result)
      private
        FSuccess: ShortInt;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: ShortInt;
        procedure SetSuccess( const Value: ShortInt);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: ShortInt read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestI32_args = interface(IBase)
        function GetThing: Integer;
        procedure SetThing( const Value: Integer);

        property Thing: Integer read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestI32_argsImpl = class(TInterfacedObject, IBase, ITestI32_args)
      private
        FThing: Integer;
        
        F__isset_Thing: Boolean;
        
        function GetThing: Integer;
        procedure SetThing( const Value: Integer);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: Integer read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestI32_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestI32_resultImpl = class(TInterfacedObject, IBase, ITestI32_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestI64_args = interface(IBase)
        function GetThing: Int64;
        procedure SetThing( const Value: Int64);

        property Thing: Int64 read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestI64_argsImpl = class(TInterfacedObject, IBase, ITestI64_args)
      private
        FThing: Int64;
        
        F__isset_Thing: Boolean;
        
        function GetThing: Int64;
        procedure SetThing( const Value: Int64);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: Int64 read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestI64_result = interface(IBase)
        function GetSuccess: Int64;
        procedure SetSuccess( const Value: Int64);

        property Success: Int64 read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestI64_resultImpl = class(TInterfacedObject, IBase, ITestI64_result)
      private
        FSuccess: Int64;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Int64;
        procedure SetSuccess( const Value: Int64);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Int64 read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestDouble_args = interface(IBase)
        function GetThing: Double;
        procedure SetThing( const Value: Double);

        property Thing: Double read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestDouble_argsImpl = class(TInterfacedObject, IBase, ITestDouble_args)
      private
        FThing: Double;
        
        F__isset_Thing: Boolean;
        
        function GetThing: Double;
        procedure SetThing( const Value: Double);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: Double read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestDouble_result = interface(IBase)
        function GetSuccess: Double;
        procedure SetSuccess( const Value: Double);

        property Success: Double read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestDouble_resultImpl = class(TInterfacedObject, IBase, ITestDouble_result)
      private
        FSuccess: Double;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Double;
        procedure SetSuccess( const Value: Double);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Double read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestStruct_args = interface(IBase)
        function GetThing: IXtruct;
        procedure SetThing( const Value: IXtruct);

        property Thing: IXtruct read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestStruct_argsImpl = class(TInterfacedObject, IBase, ITestStruct_args)
      private
        FThing: IXtruct;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IXtruct;
        procedure SetThing( const Value: IXtruct);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IXtruct read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestStruct_result = interface(IBase)
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        property Success: IXtruct read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestStruct_resultImpl = class(TInterfacedObject, IBase, ITestStruct_result)
      private
        FSuccess: IXtruct;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestNest_args = interface(IBase)
        function GetThing: IXtruct2;
        procedure SetThing( const Value: IXtruct2);

        property Thing: IXtruct2 read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestNest_argsImpl = class(TInterfacedObject, IBase, ITestNest_args)
      private
        FThing: IXtruct2;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IXtruct2;
        procedure SetThing( const Value: IXtruct2);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IXtruct2 read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestNest_result = interface(IBase)
        function GetSuccess: IXtruct2;
        procedure SetSuccess( const Value: IXtruct2);

        property Success: IXtruct2 read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestNest_resultImpl = class(TInterfacedObject, IBase, ITestNest_result)
      private
        FSuccess: IXtruct2;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IXtruct2;
        procedure SetSuccess( const Value: IXtruct2);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct2 read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestMap_args = interface(IBase)
        function GetThing: IThriftDictionary_V_V;
        procedure SetThing( const Value: IThriftDictionary_V_V);

        property Thing: IThriftDictionary_V_V read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestMap_argsImpl = class(TInterfacedObject, IBase, ITestMap_args)
      private
        FThing: IThriftDictionary_V_V;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IThriftDictionary_V_V;
        procedure SetThing( const Value: IThriftDictionary_V_V);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IThriftDictionary_V_V read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestMap_result = interface(IBase)
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestMap_resultImpl = class(TInterfacedObject, IBase, ITestMap_result)
      private
        FSuccess: IThriftDictionary_V_V;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestStringMap_args = interface(IBase)
        function GetThing: IThriftDictionary_V_V;
        procedure SetThing( const Value: IThriftDictionary_V_V);

        property Thing: IThriftDictionary_V_V read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestStringMap_argsImpl = class(TInterfacedObject, IBase, ITestStringMap_args)
      private
        FThing: IThriftDictionary_V_V;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IThriftDictionary_V_V;
        procedure SetThing( const Value: IThriftDictionary_V_V);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IThriftDictionary_V_V read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestStringMap_result = interface(IBase)
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestStringMap_resultImpl = class(TInterfacedObject, IBase, ITestStringMap_result)
      private
        FSuccess: IThriftDictionary_V_V;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestSet_args = interface(IBase)
        function GetThing: IHashSet_V;
        procedure SetThing( const Value: IHashSet_V);

        property Thing: IHashSet_V read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestSet_argsImpl = class(TInterfacedObject, IBase, ITestSet_args)
      private
        FThing: IHashSet_V;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IHashSet_V;
        procedure SetThing( const Value: IHashSet_V);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IHashSet_V read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestSet_result = interface(IBase)
        function GetSuccess: IHashSet_V;
        procedure SetSuccess( const Value: IHashSet_V);

        property Success: IHashSet_V read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestSet_resultImpl = class(TInterfacedObject, IBase, ITestSet_result)
      private
        FSuccess: IHashSet_V;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IHashSet_V;
        procedure SetSuccess( const Value: IHashSet_V);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IHashSet_V read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestList_args = interface(IBase)
        function GetThing: IThriftList_V;
        procedure SetThing( const Value: IThriftList_V);

        property Thing: IThriftList_V read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestList_argsImpl = class(TInterfacedObject, IBase, ITestList_args)
      private
        FThing: IThriftList_V;
        
        F__isset_Thing: Boolean;
        
        function GetThing: IThriftList_V;
        procedure SetThing( const Value: IThriftList_V);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: IThriftList_V read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestList_result = interface(IBase)
        function GetSuccess: IThriftList_V;
        procedure SetSuccess( const Value: IThriftList_V);

        property Success: IThriftList_V read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestList_resultImpl = class(TInterfacedObject, IBase, ITestList_result)
      private
        FSuccess: IThriftList_V;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftList_V;
        procedure SetSuccess( const Value: IThriftList_V);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftList_V read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestEnum_args = interface(IBase)
        function GetThing: TNumberz;
        procedure SetThing( const Value: TNumberz);

        property Thing: TNumberz read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestEnum_argsImpl = class(TInterfacedObject, IBase, ITestEnum_args)
      private
        FThing: TNumberz;
        
        F__isset_Thing: Boolean;
        
        function GetThing: TNumberz;
        procedure SetThing( const Value: TNumberz);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: TNumberz read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestEnum_result = interface(IBase)
        function GetSuccess: TNumberz;
        procedure SetSuccess( const Value: TNumberz);

        property Success: TNumberz read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestEnum_resultImpl = class(TInterfacedObject, IBase, ITestEnum_result)
      private
        FSuccess: TNumberz;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: TNumberz;
        procedure SetSuccess( const Value: TNumberz);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: TNumberz read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestTypedef_args = interface(IBase)
        function GetThing: TUserId;
        procedure SetThing( const Value: TUserId);

        property Thing: TUserId read GetThing write SetThing;

        function Get__isset_Thing: Boolean;

        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      TTestTypedef_argsImpl = class(TInterfacedObject, IBase, ITestTypedef_args)
      private
        FThing: TUserId;
        
        F__isset_Thing: Boolean;
        
        function GetThing: TUserId;
        procedure SetThing( const Value: TUserId);

        function Get__isset_Thing: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Thing: TUserId read GetThing write SetThing;

        // isset
        property __isset_Thing: Boolean read Get__isset_Thing;
      end;

      ITestTypedef_result = interface(IBase)
        function GetSuccess: TUserId;
        procedure SetSuccess( const Value: TUserId);

        property Success: TUserId read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestTypedef_resultImpl = class(TInterfacedObject, IBase, ITestTypedef_result)
      private
        FSuccess: TUserId;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: TUserId;
        procedure SetSuccess( const Value: TUserId);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: TUserId read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestMapMap_args = interface(IBase)
        function GetHello: Integer;
        procedure SetHello( const Value: Integer);

        property Hello: Integer read GetHello write SetHello;

        function Get__isset_Hello: Boolean;

        property __isset_Hello: Boolean read Get__isset_Hello;
      end;

      TTestMapMap_argsImpl = class(TInterfacedObject, IBase, ITestMapMap_args)
      private
        FHello: Integer;
        
        F__isset_Hello: Boolean;
        
        function GetHello: Integer;
        procedure SetHello( const Value: Integer);

        function Get__isset_Hello: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Hello: Integer read GetHello write SetHello;

        // isset
        property __isset_Hello: Boolean read Get__isset_Hello;
      end;

      ITestMapMap_result = interface(IBase)
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestMapMap_resultImpl = class(TInterfacedObject, IBase, ITestMapMap_result)
      private
        FSuccess: IThriftDictionary_V_V;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestInsanity_args = interface(IBase)
        function GetArgument: IInsanity;
        procedure SetArgument( const Value: IInsanity);

        property Argument: IInsanity read GetArgument write SetArgument;

        function Get__isset_Argument: Boolean;

        property __isset_Argument: Boolean read Get__isset_Argument;
      end;

      TTestInsanity_argsImpl = class(TInterfacedObject, IBase, ITestInsanity_args)
      private
        FArgument: IInsanity;
        
        F__isset_Argument: Boolean;
        
        function GetArgument: IInsanity;
        procedure SetArgument( const Value: IInsanity);

        function Get__isset_Argument: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Argument: IInsanity read GetArgument write SetArgument;

        // isset
        property __isset_Argument: Boolean read Get__isset_Argument;
      end;

      ITestInsanity_result = interface(IBase)
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestInsanity_resultImpl = class(TInterfacedObject, IBase, ITestInsanity_result)
      private
        FSuccess: IThriftDictionary_V_V;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IThriftDictionary_V_V;
        procedure SetSuccess( const Value: IThriftDictionary_V_V);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IThriftDictionary_V_V read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestMulti_args = interface(IBase)
        function GetArg0: ShortInt;
        procedure SetArg0( const Value: ShortInt);
        function GetArg1: Integer;
        procedure SetArg1( const Value: Integer);
        function GetArg2: Int64;
        procedure SetArg2( const Value: Int64);
        function GetArg3: IThriftDictionary_V_V;
        procedure SetArg3( const Value: IThriftDictionary_V_V);
        function GetArg4: TNumberz;
        procedure SetArg4( const Value: TNumberz);
        function GetArg5: TUserId;
        procedure SetArg5( const Value: TUserId);

        property Arg0: ShortInt read GetArg0 write SetArg0;
        property Arg1: Integer read GetArg1 write SetArg1;
        property Arg2: Int64 read GetArg2 write SetArg2;
        property Arg3: IThriftDictionary_V_V read GetArg3 write SetArg3;
        property Arg4: TNumberz read GetArg4 write SetArg4;
        property Arg5: TUserId read GetArg5 write SetArg5;

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;
        function Get__isset_Arg2: Boolean;
        function Get__isset_Arg3: Boolean;
        function Get__isset_Arg4: Boolean;
        function Get__isset_Arg5: Boolean;

        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
        property __isset_Arg2: Boolean read Get__isset_Arg2;
        property __isset_Arg3: Boolean read Get__isset_Arg3;
        property __isset_Arg4: Boolean read Get__isset_Arg4;
        property __isset_Arg5: Boolean read Get__isset_Arg5;
      end;

      TTestMulti_argsImpl = class(TInterfacedObject, IBase, ITestMulti_args)
      private
        FArg0: ShortInt;
        FArg1: Integer;
        FArg2: Int64;
        FArg3: IThriftDictionary_V_V;
        FArg4: TNumberz;
        FArg5: TUserId;
        
        F__isset_Arg0: Boolean;
        F__isset_Arg1: Boolean;
        F__isset_Arg2: Boolean;
        F__isset_Arg3: Boolean;
        F__isset_Arg4: Boolean;
        F__isset_Arg5: Boolean;
        
        function GetArg0: ShortInt;
        procedure SetArg0( const Value: ShortInt);
        function GetArg1: Integer;
        procedure SetArg1( const Value: Integer);
        function GetArg2: Int64;
        procedure SetArg2( const Value: Int64);
        function GetArg3: IThriftDictionary_V_V;
        procedure SetArg3( const Value: IThriftDictionary_V_V);
        function GetArg4: TNumberz;
        procedure SetArg4( const Value: TNumberz);
        function GetArg5: TUserId;
        procedure SetArg5( const Value: TUserId);

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;
        function Get__isset_Arg2: Boolean;
        function Get__isset_Arg3: Boolean;
        function Get__isset_Arg4: Boolean;
        function Get__isset_Arg5: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg0: ShortInt read GetArg0 write SetArg0;
        property Arg1: Integer read GetArg1 write SetArg1;
        property Arg2: Int64 read GetArg2 write SetArg2;
        property Arg3: IThriftDictionary_V_V read GetArg3 write SetArg3;
        property Arg4: TNumberz read GetArg4 write SetArg4;
        property Arg5: TUserId read GetArg5 write SetArg5;

        // isset
        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
        property __isset_Arg2: Boolean read Get__isset_Arg2;
        property __isset_Arg3: Boolean read Get__isset_Arg3;
        property __isset_Arg4: Boolean read Get__isset_Arg4;
        property __isset_Arg5: Boolean read Get__isset_Arg5;
      end;

      ITestMulti_result = interface(IBase)
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        property Success: IXtruct read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TTestMulti_resultImpl = class(TInterfacedObject, IBase, ITestMulti_result)
      private
        FSuccess: IXtruct;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ITestException_args = interface(IBase)
        function GetArg: string;
        procedure SetArg( const Value: string);

        property Arg: string read GetArg write SetArg;

        function Get__isset_Arg: Boolean;

        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      TTestException_argsImpl = class(TInterfacedObject, IBase, ITestException_args)
      private
        FArg: string;
        
        F__isset_Arg: Boolean;
        
        function GetArg: string;
        procedure SetArg( const Value: string);

        function Get__isset_Arg: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg: string read GetArg write SetArg;

        // isset
        property __isset_Arg: Boolean read Get__isset_Arg;
      end;

      ITestException_result = interface(IBase)
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);

        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;

        function Get__isset_Err1: Boolean;

        property __isset_Err1: Boolean read Get__isset_Err1;
      end;

      TTestException_resultImpl = class(TInterfacedObject, IBase, ITestException_result)
      private
        FErr1: TXception.IXceptionFactory;
        
        F__isset_Err1: Boolean;
        
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);

        function Get__isset_Err1: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;

        // isset
        property __isset_Err1: Boolean read Get__isset_Err1;
      end;

      ITestMultiException_args = interface(IBase)
        function GetArg0: string;
        procedure SetArg0( const Value: string);
        function GetArg1: string;
        procedure SetArg1( const Value: string);

        property Arg0: string read GetArg0 write SetArg0;
        property Arg1: string read GetArg1 write SetArg1;

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;

        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
      end;

      TTestMultiException_argsImpl = class(TInterfacedObject, IBase, ITestMultiException_args)
      private
        FArg0: string;
        FArg1: string;
        
        F__isset_Arg0: Boolean;
        F__isset_Arg1: Boolean;
        
        function GetArg0: string;
        procedure SetArg0( const Value: string);
        function GetArg1: string;
        procedure SetArg1( const Value: string);

        function Get__isset_Arg0: Boolean;
        function Get__isset_Arg1: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Arg0: string read GetArg0 write SetArg0;
        property Arg1: string read GetArg1 write SetArg1;

        // isset
        property __isset_Arg0: Boolean read Get__isset_Arg0;
        property __isset_Arg1: Boolean read Get__isset_Arg1;
      end;

      ITestMultiException_result = interface(IBase)
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);
        function GetErr2: TXception2.IXception2Factory;
        procedure SetErr2( const Value: TXception2.IXception2Factory);

        property Success: IXtruct read GetSuccess write SetSuccess;
        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;
        property Err2: TXception2.IXception2Factory read GetErr2 write SetErr2;

        function Get__isset_Success: Boolean;
        function Get__isset_Err1: Boolean;
        function Get__isset_Err2: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Err1: Boolean read Get__isset_Err1;
        property __isset_Err2: Boolean read Get__isset_Err2;
      end;

      TTestMultiException_resultImpl = class(TInterfacedObject, IBase, ITestMultiException_result)
      private
        FSuccess: IXtruct;
        FErr1: TXception.IXceptionFactory;
        FErr2: TXception2.IXception2Factory;
        
        F__isset_Success: Boolean;
        F__isset_Err1: Boolean;
        F__isset_Err2: Boolean;
        
        function GetSuccess: IXtruct;
        procedure SetSuccess( const Value: IXtruct);
        function GetErr1: TXception.IXceptionFactory;
        procedure SetErr1( const Value: TXception.IXceptionFactory);
        function GetErr2: TXception2.IXception2Factory;
        procedure SetErr2( const Value: TXception2.IXception2Factory);

        function Get__isset_Success: Boolean;
        function Get__isset_Err1: Boolean;
        function Get__isset_Err2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: IXtruct read GetSuccess write SetSuccess;
        property Err1: TXception.IXceptionFactory read GetErr1 write SetErr1;
        property Err2: TXception2.IXception2Factory read GetErr2 write SetErr2;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Err1: Boolean read Get__isset_Err1;
        property __isset_Err2: Boolean read Get__isset_Err2;
      end;

      ITestOneway_args = interface(IBase)
        function GetSecondsToSleep: Integer;
        procedure SetSecondsToSleep( const Value: Integer);

        property SecondsToSleep: Integer read GetSecondsToSleep write SetSecondsToSleep;

        function Get__isset_SecondsToSleep: Boolean;

        property __isset_SecondsToSleep: Boolean read Get__isset_SecondsToSleep;
      end;

      TTestOneway_argsImpl = class(TInterfacedObject, IBase, ITestOneway_args)
      private
        FSecondsToSleep: Integer;
        
        F__isset_SecondsToSleep: Boolean;
        
        function GetSecondsToSleep: Integer;
        procedure SetSecondsToSleep( const Value: Integer);

        function Get__isset_SecondsToSleep: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property SecondsToSleep: Integer read GetSecondsToSleep write SetSecondsToSleep;

        // isset
        property __isset_SecondsToSleep: Boolean read Get__isset_SecondsToSleep;
      end;

  end;
  
  TSecondService = class
  public
    type
      Iface = interface
        procedure blahBlah();
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        procedure blahBlah();
      public
        procedure send_blahBlah();
        procedure recv_blahBlah();
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = {reference to }procedure( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface) of object;
      protected
        processMap_: IThriftDictionary_V_V;{IThriftDictionary<string, TProcessFunction>;}
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
        procedure blahBlah_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
      end;

      IBlahBlah_args = interface(IBase)
      end;

      TBlahBlah_argsImpl = class(TInterfacedObject, IBase, IBlahBlah_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IBlahBlah_result = interface(IBase)
      end;

      TBlahBlah_resultImpl = class(TInterfacedObject, IBase, IBlahBlah_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; {override}

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

  end;
  
  TConstants = class
  private
    class var FmyNumberz: TNumberz;
  public
    class property myNumberz: TNumberz read FmyNumberz;
    //{$IF CompilerVersion >= 21.0}
    {$IFDEF CompilerVersion_g21}
    class constructor Create;
    class destructor Destroy;
    {$ENDIF}
  end;

implementation

constructor TBonkImpl.Create;
begin
  inherited;
end;

destructor TBonkImpl.Destroy;
begin
  inherited;
end;

function TBonkImpl.GetMessage: string;
begin
  Result := FMessage;
end;

procedure TBonkImpl.SetMessage( const Value: string);
begin
  F__isset_Message := True;
  FMessage := Value;
end;

function TBonkImpl.Get__isset_Message: Boolean;
begin
  Result := F__isset_Message;
end;

function TBonkImpl.GetType_: Integer;
begin
  Result := FType_;
end;

procedure TBonkImpl.SetType_( const Value: Integer);
begin
  F__isset_Type_ := True;
  FType_ := Value;
end;

function TBonkImpl.Get__isset_Type_: Boolean;
begin
  Result := F__isset_Type_;
end;

procedure TBonkImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Message := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Type_ := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TBonkImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Bonk');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Message) then
  begin
    field_.Name := 'message';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Message);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Type_) then
  begin
    field_.Name := 'type';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Type_);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TBonkImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Message: ');
    sb.Append(Message);
    sb.Append(',Type_: ');
    sb.Append(Type_);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TBoolsImpl.Create;
begin
  inherited;
end;

destructor TBoolsImpl.Destroy;
begin
  inherited;
end;

function TBoolsImpl.GetIm_true: Boolean;
begin
  Result := FIm_true;
end;

procedure TBoolsImpl.SetIm_true( const Value: Boolean);
begin
  F__isset_Im_true := True;
  FIm_true := Value;
end;

function TBoolsImpl.Get__isset_Im_true: Boolean;
begin
  Result := F__isset_Im_true;
end;

function TBoolsImpl.GetIm_false: Boolean;
begin
  Result := FIm_false;
end;

procedure TBoolsImpl.SetIm_false( const Value: Boolean);
begin
  F__isset_Im_false := True;
  FIm_false := Value;
end;

function TBoolsImpl.Get__isset_Im_false: Boolean;
begin
  Result := F__isset_Im_false;
end;

procedure TBoolsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Im_true := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Im_false := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TBoolsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Bools');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Im_true) then
  begin
    field_.Name := 'im_true';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Im_true);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Im_false) then
  begin
    field_.Name := 'im_false';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Im_false);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TBoolsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Im_true: ');
    sb.Append(Im_true);
    sb.Append(',Im_false: ');
    sb.Append(Im_false);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXtructImpl.Create;
begin
  inherited;
end;

destructor TXtructImpl.Destroy;
begin
  inherited;
end;

function TXtructImpl.GetString_thing: string;
begin
  Result := FString_thing;
end;

procedure TXtructImpl.SetString_thing( const Value: string);
begin
  F__isset_String_thing := True;
  FString_thing := Value;
end;

function TXtructImpl.Get__isset_String_thing: Boolean;
begin
  Result := F__isset_String_thing;
end;

function TXtructImpl.GetByte_thing: ShortInt;
begin
  Result := FByte_thing;
end;

procedure TXtructImpl.SetByte_thing( const Value: ShortInt);
begin
  F__isset_Byte_thing := True;
  FByte_thing := Value;
end;

function TXtructImpl.Get__isset_Byte_thing: Boolean;
begin
  Result := F__isset_Byte_thing;
end;

function TXtructImpl.GetI32_thing: Integer;
begin
  Result := FI32_thing;
end;

procedure TXtructImpl.SetI32_thing( const Value: Integer);
begin
  F__isset_I32_thing := True;
  FI32_thing := Value;
end;

function TXtructImpl.Get__isset_I32_thing: Boolean;
begin
  Result := F__isset_I32_thing;
end;

function TXtructImpl.GetI64_thing: Int64;
begin
  Result := FI64_thing;
end;

procedure TXtructImpl.SetI64_thing( const Value: Int64);
begin
  F__isset_I64_thing := True;
  FI64_thing := Value;
end;

function TXtructImpl.Get__isset_I64_thing: Boolean;
begin
  Result := F__isset_I64_thing;
end;

procedure TXtructImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            String_thing := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Byte_thing := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        9: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            I32_thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        11: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            I64_thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXtructImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xtruct');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_String_thing) then
  begin
    field_.Name := 'string_thing';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(String_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Byte_thing) then
  begin
    field_.Name := 'byte_thing';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Byte_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I32_thing) then
  begin
    field_.Name := 'i32_thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 9;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(I32_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I64_thing) then
  begin
    field_.Name := 'i64_thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 11;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(I64_thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXtructImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('String_thing: ');
    sb.Append(String_thing);
    sb.Append(',Byte_thing: ');
    sb.Append(Byte_thing);
    sb.Append(',I32_thing: ');
    sb.Append(I32_thing);
    sb.Append(',I64_thing: ');
    sb.Append(I64_thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXtruct2Impl.Create;
begin
  inherited;
end;

destructor TXtruct2Impl.Destroy;
begin
  inherited;
end;

function TXtruct2Impl.GetByte_thing: ShortInt;
begin
  Result := FByte_thing;
end;

procedure TXtruct2Impl.SetByte_thing( const Value: ShortInt);
begin
  F__isset_Byte_thing := True;
  FByte_thing := Value;
end;

function TXtruct2Impl.Get__isset_Byte_thing: Boolean;
begin
  Result := F__isset_Byte_thing;
end;

function TXtruct2Impl.GetStruct_thing: IXtruct;
begin
  Result := FStruct_thing;
end;

procedure TXtruct2Impl.SetStruct_thing( const Value: IXtruct);
begin
  F__isset_Struct_thing := True;
  FStruct_thing := Value;
end;

function TXtruct2Impl.Get__isset_Struct_thing: Boolean;
begin
  Result := F__isset_Struct_thing;
end;

function TXtruct2Impl.GetI32_thing: Integer;
begin
  Result := FI32_thing;
end;

procedure TXtruct2Impl.SetI32_thing( const Value: Integer);
begin
  F__isset_I32_thing := True;
  FI32_thing := Value;
end;

function TXtruct2Impl.Get__isset_I32_thing: Boolean;
begin
  Result := F__isset_I32_thing;
end;

procedure TXtruct2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Byte_thing := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Struct_thing := TXtructImpl.Create;
            Struct_thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            I32_thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXtruct2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xtruct2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Byte_thing) then
  begin
    field_.Name := 'byte_thing';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Byte_thing);
    oprot.WriteFieldEnd();
  end;
  if (Struct_thing <> nil) and __isset_Struct_thing then
  begin
    field_.Name := 'struct_thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Struct_thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I32_thing) then
  begin
    field_.Name := 'i32_thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(I32_thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXtruct2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Byte_thing: ');
    sb.Append(Byte_thing);
    sb.Append(',Struct_thing: ');
    if (Struct_thing = nil) then sb.Append('<null>') else sb.Append(Struct_thing.ToString());
    sb.Append(',I32_thing: ');
    sb.Append(I32_thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXtruct3Impl.Create;
begin
  inherited;
end;

destructor TXtruct3Impl.Destroy;
begin
  inherited;
end;

function TXtruct3Impl.GetString_thing: string;
begin
  Result := FString_thing;
end;

procedure TXtruct3Impl.SetString_thing( const Value: string);
begin
  F__isset_String_thing := True;
  FString_thing := Value;
end;

function TXtruct3Impl.Get__isset_String_thing: Boolean;
begin
  Result := F__isset_String_thing;
end;

function TXtruct3Impl.GetChanged: Integer;
begin
  Result := FChanged;
end;

procedure TXtruct3Impl.SetChanged( const Value: Integer);
begin
  F__isset_Changed := True;
  FChanged := Value;
end;

function TXtruct3Impl.Get__isset_Changed: Boolean;
begin
  Result := F__isset_Changed;
end;

function TXtruct3Impl.GetI32_thing: Integer;
begin
  Result := FI32_thing;
end;

procedure TXtruct3Impl.SetI32_thing( const Value: Integer);
begin
  F__isset_I32_thing := True;
  FI32_thing := Value;
end;

function TXtruct3Impl.Get__isset_I32_thing: Boolean;
begin
  Result := F__isset_I32_thing;
end;

function TXtruct3Impl.GetI64_thing: Int64;
begin
  Result := FI64_thing;
end;

procedure TXtruct3Impl.SetI64_thing( const Value: Int64);
begin
  F__isset_I64_thing := True;
  FI64_thing := Value;
end;

function TXtruct3Impl.Get__isset_I64_thing: Boolean;
begin
  Result := F__isset_I64_thing;
end;

procedure TXtruct3Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            String_thing := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Changed := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        9: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            I32_thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        11: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            I64_thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXtruct3Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xtruct3');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_String_thing) then
  begin
    field_.Name := 'string_thing';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(String_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Changed) then
  begin
    field_.Name := 'changed';
    field_.Type_  := {TType.}I32;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Changed);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I32_thing) then
  begin
    field_.Name := 'i32_thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 9;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(I32_thing);
    oprot.WriteFieldEnd();
  end;
  if (__isset_I64_thing) then
  begin
    field_.Name := 'i64_thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 11;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(I64_thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXtruct3Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('String_thing: ');
    sb.Append(String_thing);
    sb.Append(',Changed: ');
    sb.Append(Changed);
    sb.Append(',I32_thing: ');
    sb.Append(I32_thing);
    sb.Append(',I64_thing: ');
    sb.Append(I64_thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TInsanityImpl.Create;
begin
  inherited;
end;

destructor TInsanityImpl.Destroy;
begin
  inherited;
end;

function TInsanityImpl.GetUserMap: IThriftDictionary_V_V;
begin
  Result := FUserMap;
end;

procedure TInsanityImpl.SetUserMap( const Value: IThriftDictionary_V_V);
begin
  F__isset_UserMap := True;
  FUserMap := Value;
end;

function TInsanityImpl.Get__isset_UserMap: Boolean;
begin
  Result := F__isset_UserMap;
end;

function TInsanityImpl.GetXtructs: IThriftList_V;
begin
  Result := FXtructs;
end;

procedure TInsanityImpl.SetXtructs( const Value: IThriftList_V);
begin
  F__isset_Xtructs := True;
  FXtructs := Value;
end;

function TInsanityImpl.Get__isset_Xtructs: Boolean;
begin
  Result := F__isset_Xtructs;
end;

procedure TInsanityImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map0: IMap;
  _i1: Integer;
  _key2: TNumberz;
  _val3: TUserId;
  _list4: IList;
  _i5: Integer;
  _elem6: IXtruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            UserMap := TThriftDictionary_V_VImpl.Create;
            _map0 := iprot.ReadMapBegin();
            for _i1 := 0 to _map0.Count - 1 do
            begin
              _key2 := TNumberz(iprot.ReadI32());
              _val3 := iprot.ReadI64();
              UserMap.AddOrSetValue( _key2, _val3);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Xtructs := TThriftList_VImpl.Create;
            _list4 := iprot.ReadListBegin();
            for _i5 := 0 to _list4.Count - 1 do
            begin
              _elem6 := TXtructImpl.Create;
              _elem6.Read(iprot);
              Xtructs.Add(_elem6);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TInsanityImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map7 : IMap;
  _iter8: TNumberz;
  list_9 : IList;
  _iter10: IXtruct;
begin
  struc := TStructImpl.Create('Insanity');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (UserMap <> nil) and __isset_UserMap then
  begin
    field_.Name := 'userMap';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map7 := TMapImpl.Create( {TType.}I32, {TType.}I64, UserMap.Count);
    oprot.WriteMapBegin( map7);
    for _iter8 in UserMap.Keys do
    begin
      oprot.WriteI32(Integer(_iter8));
      oprot.WriteI64(UserMap[_iter8]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (Xtructs <> nil) and __isset_Xtructs then
  begin
    field_.Name := 'xtructs';
    field_.Type_  := {TType.}List;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    list_9 := TListImpl.Create({TType.}Struct, Xtructs.Count);
    oprot.WriteListBegin( list_9);
    for _iter10 in Xtructs do
    begin
      _iter10.Write(oprot);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TInsanityImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('UserMap: ');
    sb.Append(UserMap);
    sb.Append(',Xtructs: ');
    sb.Append(Xtructs);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TCrazyNestingImpl.Create;
begin
  inherited;
end;

destructor TCrazyNestingImpl.Destroy;
begin
  inherited;
end;

function TCrazyNestingImpl.GetString_field: string;
begin
  Result := FString_field;
end;

procedure TCrazyNestingImpl.SetString_field( const Value: string);
begin
  F__isset_String_field := True;
  FString_field := Value;
end;

function TCrazyNestingImpl.Get__isset_String_field: Boolean;
begin
  Result := F__isset_String_field;
end;

function TCrazyNestingImpl.GetSet_field: IHashSet_V;
begin
  Result := FSet_field;
end;

procedure TCrazyNestingImpl.SetSet_field( const Value: IHashSet_V);
begin
  F__isset_Set_field := True;
  FSet_field := Value;
end;

function TCrazyNestingImpl.Get__isset_Set_field: Boolean;
begin
  Result := F__isset_Set_field;
end;

function TCrazyNestingImpl.GetList_field: IThriftList_V;
begin
  Result := FList_field;
end;

procedure TCrazyNestingImpl.SetList_field( const Value: IThriftList_V);
begin
  FList_field := Value;
end;

function TCrazyNestingImpl.GetBinary_field: TBytes;
begin
  Result := FBinary_field;
end;

procedure TCrazyNestingImpl.SetBinary_field( const Value: TBytes);
begin
  F__isset_Binary_field := True;
  FBinary_field := Value;
end;

function TCrazyNestingImpl.Get__isset_Binary_field: Boolean;
begin
  Result := F__isset_Binary_field;
end;

procedure TCrazyNestingImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _req_isset_List_field : Boolean;
  _set11: ISet;
  _i12: Integer;
  _elem13: IInsanity;
  _list14: IList;
  _i15: Integer;
  _elem16: IThriftDictionary_V_V;
  _map17: IMap;
  _i18: Integer;
  _key19: IHashSet_V;
  _val20: IThriftDictionary_V_V;
  _set21: ISet;
  _i22: Integer;
  _elem23: Integer;
  _map24: IMap;
  _i25: Integer;
  _key26: Integer;
  _val27: IHashSet_V;
  _set28: ISet;
  _i29: Integer;
  _elem30: IThriftList_V;
  _list31: IList;
  _i32: Integer;
  _elem33: IThriftDictionary_V_V;
  _map34: IMap;
  _i35: Integer;
  _key36: IInsanity;
  _val37: string;

begin
  _req_isset_List_field := FALSE;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            String_field := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Set_field := THashSet_VImpl.Create;
            _set11 := iprot.ReadSetBegin();
            for _i12 := 0 to _set11.Count - 1 do
            begin
              _elem13 := TInsanityImpl.Create;
              _elem13.Read(iprot);
              Set_field.Add(_elem13);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}List) then
          begin
            List_field := TThriftList_VImpl.Create;
            _list14 := iprot.ReadListBegin();
            for _i15 := 0 to _list14.Count - 1 do
            begin
              _elem16 := TThriftDictionary_V_VImpl.Create;
              _map17 := iprot.ReadMapBegin();
              for _i18 := 0 to _map17.Count - 1 do
              begin
                _key19 := THashSet_VImpl.Create;
                _set21 := iprot.ReadSetBegin();
                for _i22 := 0 to _set21.Count - 1 do
                begin
                  _elem23 := iprot.ReadI32();
                  _key19.Add(_elem23);
                end;
                iprot.ReadSetEnd();
                _val20 := TThriftDictionary_V_VImpl.Create;
                _map24 := iprot.ReadMapBegin();
                for _i25 := 0 to _map24.Count - 1 do
                begin
                  _key26 := iprot.ReadI32();
                  _val27 := THashSet_VImpl.Create;
                  _set28 := iprot.ReadSetBegin();
                  for _i29 := 0 to _set28.Count - 1 do
                  begin
                    _elem30 := TThriftList_VImpl.Create;
                    _list31 := iprot.ReadListBegin();
                    for _i32 := 0 to _list31.Count - 1 do
                    begin
                      _elem33 := TThriftDictionary_V_VImpl.Create;
                      _map34 := iprot.ReadMapBegin();
                      for _i35 := 0 to _map34.Count - 1 do
                      begin
                        _key36 := TInsanityImpl.Create;
                        _key36.Read(iprot);
                        _val37 := iprot.ReadString();
                        _elem33.AddOrSetValue( _key36, _val37);
                      end;
                      iprot.ReadMapEnd();
                      _elem30.Add(_elem33);
                    end;
                    iprot.ReadListEnd();
                    _val27.Add(_elem30);
                  end;
                  iprot.ReadSetEnd();
                  _val20.AddOrSetValue( _key26, _val27);
                end;
                iprot.ReadMapEnd();
                _elem16.AddOrSetValue( _key19, _val20);
              end;
              iprot.ReadMapEnd();
              List_field.Add(_elem16);
            end;
            iprot.ReadListEnd();
            _req_isset_List_field := TRUE;
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Binary_field := iprot.ReadBinary();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
  if not _req_isset_List_field
  then raise TProtocolException.Create( TProtocolException.INVALID_DATA, 'List_field');
end;

procedure TCrazyNestingImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_38 : ISet;
  _iter39: IInsanity;
  list_40 : IList;
  _iter41: IThriftDictionary_V_V;
  map42 : IMap;
  _iter43: IHashSet_V;
  set_44 : ISet;
  _iter45: Integer;
  map46 : IMap;
  _iter47: Integer;
  set_48 : ISet;
  _iter49: IThriftList_V;
  list_50 : IList;
  _iter51: IThriftDictionary_V_V;
  map52 : IMap;
  _iter53: IInsanity;
begin
  struc := TStructImpl.Create('CrazyNesting');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_String_field) then
  begin
    field_.Name := 'string_field';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(String_field);
    oprot.WriteFieldEnd();
  end;
  if (Set_field <> nil) and __isset_Set_field then
  begin
    field_.Name := 'set_field';
    field_.Type_  := {TType.}Set_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    set_38 := TSetImpl.Create({TType.}Struct, Set_field.Count);
    oprot.WriteSetBegin( set_38);
    for _iter39 in Set_field do
    begin
      _iter39.Write(oprot);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  if (List_field <> nil) then
  begin
    field_.Name := 'list_field';
    field_.Type_  := {TType.}List;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    list_40 := TListImpl.Create({TType.}Map, List_field.Count);
    oprot.WriteListBegin( list_40);
    for _iter41 in List_field do
    begin
      map42 := TMapImpl.Create( {TType.}Set_, {TType.}Map, _iter41.Count);
      oprot.WriteMapBegin( map42);
      for _iter43 in _iter41.Keys do
      begin
        set_44 := TSetImpl.Create({TType.}I32, _iter43.Count);
        oprot.WriteSetBegin( set_44);
        for _iter45 in _iter43 do
        begin
          oprot.WriteI32(_iter45);
        end;
        oprot.WriteSetEnd();
        map46 := TMapImpl.Create( {TType.}I32, {TType.}Set_, _iter41[_iter43].Count);
        oprot.WriteMapBegin( map46);
        for _iter47 in _iter41[_iter43].Keys do
        begin
          oprot.WriteI32(_iter47);
          set_48 := TSetImpl.Create({TType.}List, _iter41[_iter43][_iter47].Count);
          oprot.WriteSetBegin( set_48);
          for _iter49 in _iter41[_iter43][_iter47] do
          begin
            list_50 := TListImpl.Create({TType.}Map, _iter49.Count);
            oprot.WriteListBegin( list_50);
            for _iter51 in _iter49 do
            begin
              map52 := TMapImpl.Create( {TType.}Struct, {TType.}String_, _iter51.Count);
              oprot.WriteMapBegin( map52);
              for _iter53 in _iter51.Keys do
              begin
                _iter53.Write(oprot);
                oprot.WriteString(_iter51[_iter53]);
              end;
              oprot.WriteMapEnd();
            end;
            oprot.WriteListEnd();
          end;
          oprot.WriteSetEnd();
        end;
        oprot.WriteMapEnd();
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Binary_field) then
  begin
    field_.Name := 'binary_field';
    field_.Type_  := {TType.}String_;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBinary(Binary_field);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCrazyNestingImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('String_field: ');
    sb.Append(String_field);
    sb.Append(',Set_field: ');
    sb.Append(Set_field);
    sb.Append(',List_field: ');
    sb.Append(List_field);
    sb.Append(',Binary_field: ');
    sb.Append(Binary_field);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXception.TXceptionFactoryImpl.Create;
begin
  inherited;
end;

destructor TXception.TXceptionFactoryImpl.Destroy;
begin
  inherited;
end;

function TXception.TXceptionFactoryImpl.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception.TXceptionFactoryImpl.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
end;

function TXception.TXceptionFactoryImpl.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception.TXceptionFactoryImpl.GetMessage_: string;
begin
  Result := FMessage_;
end;

procedure TXception.TXceptionFactoryImpl.SetMessage_( const Value: string);
begin
  F__isset_Message_ := True;
  FMessage_ := Value;
end;

function TXception.TXceptionFactoryImpl.Get__isset_Message_: Boolean;
begin
  Result := F__isset_Message_;
end;

procedure TXception.TXceptionFactoryImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            ErrorCode := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Message_ := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXception.TXceptionFactoryImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xception');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_ErrorCode) then
  begin
    field_.Name := 'errorCode';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(ErrorCode);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Message_) then
  begin
    field_.Name := 'message';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Message_);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXception.TXceptionFactoryImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Message_: ');
    sb.Append(Message_);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

function TXception.TXceptionFactoryImpl.CreateException: TXception;
begin
  Result := TXception.Create;
  Result.XceptionFactory := Self;
  if __isset_ErrorCode then
  begin
    Result.ErrorCode := ErrorCode;
  end;
  if __isset_Message_ then
  begin
    Result.Message_ := Message_;
  end;
  Result.UpdateMessageProperty;
end;

constructor TXception.Create;
begin
  inherited Create('');
  FXceptionFactory := TXceptionFactoryImpl.Create;
end;

constructor TXception.Create( AErrorCode: Integer; const AMessage: string);
begin
  Create;
  ErrorCode := AErrorCode;
  Message_ := AMessage;
  UpdateMessageProperty;
end;

destructor TXception.Destroy;
begin
  inherited;
end;

function TXception.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
  FXceptionFactory.ErrorCode := Value;
end;

function TXception.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception.GetMessage_: string;
begin
  Result := FMessage_;
end;

procedure TXception.SetMessage_( const Value: string);
begin
  F__isset_Message_ := True;
  FMessage_ := Value;
  FXceptionFactory.Message_ := Value;
end;

function TXception.Get__isset_Message_: Boolean;
begin
  Result := F__isset_Message_;
end;

function TXception.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Message_: ');
    sb.Append(Message_);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TXception2.TXception2FactoryImpl.Create;
begin
  inherited;
end;

destructor TXception2.TXception2FactoryImpl.Destroy;
begin
  inherited;
end;

function TXception2.TXception2FactoryImpl.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception2.TXception2FactoryImpl.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
end;

function TXception2.TXception2FactoryImpl.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception2.TXception2FactoryImpl.GetStruct_thing: IXtruct;
begin
  Result := FStruct_thing;
end;

procedure TXception2.TXception2FactoryImpl.SetStruct_thing( const Value: IXtruct);
begin
  F__isset_Struct_thing := True;
  FStruct_thing := Value;
end;

function TXception2.TXception2FactoryImpl.Get__isset_Struct_thing: Boolean;
begin
  Result := F__isset_Struct_thing;
end;

procedure TXception2.TXception2FactoryImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            ErrorCode := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Struct_thing := TXtructImpl.Create;
            Struct_thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TXception2.TXception2FactoryImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('Xception2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_ErrorCode) then
  begin
    field_.Name := 'errorCode';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(ErrorCode);
    oprot.WriteFieldEnd();
  end;
  if (Struct_thing <> nil) and __isset_Struct_thing then
  begin
    field_.Name := 'struct_thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Struct_thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TXception2.TXception2FactoryImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Struct_thing: ');
    if (Struct_thing = nil) then sb.Append('<null>') else sb.Append(Struct_thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

function TXception2.TXception2FactoryImpl.CreateException: TXception2;
begin
  Result := TXception2.Create;
  Result.Xception2Factory := Self;
  if __isset_ErrorCode then
  begin
    Result.ErrorCode := ErrorCode;
  end;
  if __isset_Struct_thing then
  begin
    Result.Struct_thing := Struct_thing;
  end;
  Result.UpdateMessageProperty;
end;

constructor TXception2.Create;
begin
  inherited Create('');
  FXception2Factory := TXception2FactoryImpl.Create;
end;

constructor TXception2.Create( AErrorCode: Integer; const AStruct_thing: IXtruct);
begin
  Create;
  ErrorCode := AErrorCode;
  Struct_thing := AStruct_thing;
  UpdateMessageProperty;
end;

destructor TXception2.Destroy;
begin
  inherited;
end;

function TXception2.GetErrorCode: Integer;
begin
  Result := FErrorCode;
end;

procedure TXception2.SetErrorCode( const Value: Integer);
begin
  F__isset_ErrorCode := True;
  FErrorCode := Value;
  FXception2Factory.ErrorCode := Value;
end;

function TXception2.Get__isset_ErrorCode: Boolean;
begin
  Result := F__isset_ErrorCode;
end;

function TXception2.GetStruct_thing: IXtruct;
begin
  Result := FStruct_thing;
end;

procedure TXception2.SetStruct_thing( const Value: IXtruct);
begin
  F__isset_Struct_thing := True;
  FStruct_thing := Value;
  FXception2Factory.Struct_thing := Value;
end;

function TXception2.Get__isset_Struct_thing: Boolean;
begin
  Result := F__isset_Struct_thing;
end;

function TXception2.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('ErrorCode: ');
    sb.Append(ErrorCode);
    sb.Append(',Struct_thing: ');
    if (Struct_thing = nil) then sb.Append('<null>') else sb.Append(Struct_thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TEmptyStructImpl.Create;
begin
  inherited;
end;

destructor TEmptyStructImpl.Destroy;
begin
  inherited;
end;

procedure TEmptyStructImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TEmptyStructImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('EmptyStruct');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TEmptyStructImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TOneFieldImpl.Create;
begin
  inherited;
end;

destructor TOneFieldImpl.Destroy;
begin
  inherited;
end;

function TOneFieldImpl.GetField: IEmptyStruct;
begin
  Result := FField;
end;

procedure TOneFieldImpl.SetField( const Value: IEmptyStruct);
begin
  F__isset_Field := True;
  FField := Value;
end;

function TOneFieldImpl.Get__isset_Field: Boolean;
begin
  Result := F__isset_Field;
end;

procedure TOneFieldImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Field := TEmptyStructImpl.Create;
            Field.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TOneFieldImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('OneField');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Field <> nil) and __isset_Field then
  begin
    field_.Name := 'field';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Field.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TOneFieldImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Field: ');
    if (Field = nil) then sb.Append('<null>') else sb.Append(Field.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TVersioningTestV1Impl.Create;
begin
  inherited;
end;

destructor TVersioningTestV1Impl.Destroy;
begin
  inherited;
end;

function TVersioningTestV1Impl.GetBegin_in_both: Integer;
begin
  Result := FBegin_in_both;
end;

procedure TVersioningTestV1Impl.SetBegin_in_both( const Value: Integer);
begin
  F__isset_Begin_in_both := True;
  FBegin_in_both := Value;
end;

function TVersioningTestV1Impl.Get__isset_Begin_in_both: Boolean;
begin
  Result := F__isset_Begin_in_both;
end;

function TVersioningTestV1Impl.GetOld_string: string;
begin
  Result := FOld_string;
end;

procedure TVersioningTestV1Impl.SetOld_string( const Value: string);
begin
  F__isset_Old_string := True;
  FOld_string := Value;
end;

function TVersioningTestV1Impl.Get__isset_Old_string: Boolean;
begin
  Result := F__isset_Old_string;
end;

function TVersioningTestV1Impl.GetEnd_in_both: Integer;
begin
  Result := FEnd_in_both;
end;

procedure TVersioningTestV1Impl.SetEnd_in_both( const Value: Integer);
begin
  F__isset_End_in_both := True;
  FEnd_in_both := Value;
end;

function TVersioningTestV1Impl.Get__isset_End_in_both: Boolean;
begin
  Result := F__isset_End_in_both;
end;

procedure TVersioningTestV1Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Begin_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Old_string := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        12: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            End_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TVersioningTestV1Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('VersioningTestV1');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Begin_in_both) then
  begin
    field_.Name := 'begin_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Begin_in_both);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Old_string) then
  begin
    field_.Name := 'old_string';
    field_.Type_  := {TType.}String_;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Old_string);
    oprot.WriteFieldEnd();
  end;
  if (__isset_End_in_both) then
  begin
    field_.Name := 'end_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 12;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(End_in_both);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TVersioningTestV1Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Begin_in_both: ');
    sb.Append(Begin_in_both);
    sb.Append(',Old_string: ');
    sb.Append(Old_string);
    sb.Append(',End_in_both: ');
    sb.Append(End_in_both);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TVersioningTestV2Impl.Create;
begin
  inherited;
end;

destructor TVersioningTestV2Impl.Destroy;
begin
  inherited;
end;

function TVersioningTestV2Impl.GetBegin_in_both: Integer;
begin
  Result := FBegin_in_both;
end;

procedure TVersioningTestV2Impl.SetBegin_in_both( const Value: Integer);
begin
  F__isset_Begin_in_both := True;
  FBegin_in_both := Value;
end;

function TVersioningTestV2Impl.Get__isset_Begin_in_both: Boolean;
begin
  Result := F__isset_Begin_in_both;
end;

function TVersioningTestV2Impl.GetNewint: Integer;
begin
  Result := FNewint;
end;

procedure TVersioningTestV2Impl.SetNewint( const Value: Integer);
begin
  F__isset_Newint := True;
  FNewint := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newint: Boolean;
begin
  Result := F__isset_Newint;
end;

function TVersioningTestV2Impl.GetNewbyte: ShortInt;
begin
  Result := FNewbyte;
end;

procedure TVersioningTestV2Impl.SetNewbyte( const Value: ShortInt);
begin
  F__isset_Newbyte := True;
  FNewbyte := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newbyte: Boolean;
begin
  Result := F__isset_Newbyte;
end;

function TVersioningTestV2Impl.GetNewshort: SmallInt;
begin
  Result := FNewshort;
end;

procedure TVersioningTestV2Impl.SetNewshort( const Value: SmallInt);
begin
  F__isset_Newshort := True;
  FNewshort := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newshort: Boolean;
begin
  Result := F__isset_Newshort;
end;

function TVersioningTestV2Impl.GetNewlong: Int64;
begin
  Result := FNewlong;
end;

procedure TVersioningTestV2Impl.SetNewlong( const Value: Int64);
begin
  F__isset_Newlong := True;
  FNewlong := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newlong: Boolean;
begin
  Result := F__isset_Newlong;
end;

function TVersioningTestV2Impl.GetNewdouble: Double;
begin
  Result := FNewdouble;
end;

procedure TVersioningTestV2Impl.SetNewdouble( const Value: Double);
begin
  F__isset_Newdouble := True;
  FNewdouble := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newdouble: Boolean;
begin
  Result := F__isset_Newdouble;
end;

function TVersioningTestV2Impl.GetNewstruct: IBonk;
begin
  Result := FNewstruct;
end;

procedure TVersioningTestV2Impl.SetNewstruct( const Value: IBonk);
begin
  F__isset_Newstruct := True;
  FNewstruct := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newstruct: Boolean;
begin
  Result := F__isset_Newstruct;
end;

function TVersioningTestV2Impl.GetNewlist: IThriftList_V;
begin
  Result := FNewlist;
end;

procedure TVersioningTestV2Impl.SetNewlist( const Value: IThriftList_V);
begin
  F__isset_Newlist := True;
  FNewlist := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newlist: Boolean;
begin
  Result := F__isset_Newlist;
end;

function TVersioningTestV2Impl.GetNewset: IHashSet_V;
begin
  Result := FNewset;
end;

procedure TVersioningTestV2Impl.SetNewset( const Value: IHashSet_V);
begin
  F__isset_Newset := True;
  FNewset := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newset: Boolean;
begin
  Result := F__isset_Newset;
end;

function TVersioningTestV2Impl.GetNewmap: IThriftDictionary_V_V;
begin
  Result := FNewmap;
end;

procedure TVersioningTestV2Impl.SetNewmap( const Value: IThriftDictionary_V_V);
begin
  F__isset_Newmap := True;
  FNewmap := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newmap: Boolean;
begin
  Result := F__isset_Newmap;
end;

function TVersioningTestV2Impl.GetNewstring: string;
begin
  Result := FNewstring;
end;

procedure TVersioningTestV2Impl.SetNewstring( const Value: string);
begin
  F__isset_Newstring := True;
  FNewstring := Value;
end;

function TVersioningTestV2Impl.Get__isset_Newstring: Boolean;
begin
  Result := F__isset_Newstring;
end;

function TVersioningTestV2Impl.GetEnd_in_both: Integer;
begin
  Result := FEnd_in_both;
end;

procedure TVersioningTestV2Impl.SetEnd_in_both( const Value: Integer);
begin
  F__isset_End_in_both := True;
  FEnd_in_both := Value;
end;

function TVersioningTestV2Impl.Get__isset_End_in_both: Boolean;
begin
  Result := F__isset_End_in_both;
end;

procedure TVersioningTestV2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list54: IList;
  _i55: Integer;
  _elem56: Integer;
  _set57: ISet;
  _i58: Integer;
  _elem59: Integer;
  _map60: IMap;
  _i61: Integer;
  _key62: Integer;
  _val63: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Begin_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Newint := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Newbyte := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}I16) then
          begin
            Newshort := iprot.ReadI16();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        5: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Newlong := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        6: begin
          if (field_.Type_ = {TType.}Double_) then
          begin
            Newdouble := iprot.ReadDouble();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        7: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Newstruct := TBonkImpl.Create;
            Newstruct.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        8: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Newlist := TThriftList_VImpl.Create;
            _list54 := iprot.ReadListBegin();
            for _i55 := 0 to _list54.Count - 1 do
            begin
              _elem56 := iprot.ReadI32();
              Newlist.Add(_elem56);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        9: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Newset := THashSet_VImpl.Create;
            _set57 := iprot.ReadSetBegin();
            for _i58 := 0 to _set57.Count - 1 do
            begin
              _elem59 := iprot.ReadI32();
              Newset.Add(_elem59);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        10: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Newmap := TThriftDictionary_V_VImpl.Create;
            _map60 := iprot.ReadMapBegin();
            for _i61 := 0 to _map60.Count - 1 do
            begin
              _key62 := iprot.ReadI32();
              _val63 := iprot.ReadI32();
              Newmap.AddOrSetValue( _key62, _val63);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        11: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Newstring := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        12: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            End_in_both := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TVersioningTestV2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_64 : IList;
  _iter65: Integer;
  set_66 : ISet;
  _iter67: Integer;
  map68 : IMap;
  _iter69: Integer;
begin
  struc := TStructImpl.Create('VersioningTestV2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Begin_in_both) then
  begin
    field_.Name := 'begin_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Begin_in_both);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newint) then
  begin
    field_.Name := 'newint';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Newint);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newbyte) then
  begin
    field_.Name := 'newbyte';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Newbyte);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newshort) then
  begin
    field_.Name := 'newshort';
    field_.Type_  := {TType.}I16;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI16(Newshort);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newlong) then
  begin
    field_.Name := 'newlong';
    field_.Type_  := {TType.}I64;
    field_.ID := 5;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Newlong);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newdouble) then
  begin
    field_.Name := 'newdouble';
    field_.Type_  := {TType.}Double_;
    field_.ID := 6;
    oprot.WriteFieldBegin(field_);
    oprot.WriteDouble(Newdouble);
    oprot.WriteFieldEnd();
  end;
  if (Newstruct <> nil) and __isset_Newstruct then
  begin
    field_.Name := 'newstruct';
    field_.Type_  := {TType.}Struct;
    field_.ID := 7;
    oprot.WriteFieldBegin(field_);
    Newstruct.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Newlist <> nil) and __isset_Newlist then
  begin
    field_.Name := 'newlist';
    field_.Type_  := {TType.}List;
    field_.ID := 8;
    oprot.WriteFieldBegin(field_);
    list_64 := TListImpl.Create({TType.}I32, Newlist.Count);
    oprot.WriteListBegin( list_64);
    for _iter65 in Newlist do
    begin
      oprot.WriteI32(_iter65);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (Newset <> nil) and __isset_Newset then
  begin
    field_.Name := 'newset';
    field_.Type_  := {TType.}Set_;
    field_.ID := 9;
    oprot.WriteFieldBegin(field_);
    set_66 := TSetImpl.Create({TType.}I32, Newset.Count);
    oprot.WriteSetBegin( set_66);
    for _iter67 in Newset do
    begin
      oprot.WriteI32(_iter67);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  if (Newmap <> nil) and __isset_Newmap then
  begin
    field_.Name := 'newmap';
    field_.Type_  := {TType.}Map;
    field_.ID := 10;
    oprot.WriteFieldBegin(field_);
    map68 := TMapImpl.Create( {TType.}I32, {TType.}I32, Newmap.Count);
    oprot.WriteMapBegin( map68);
    for _iter69 in Newmap.Keys do
    begin
      oprot.WriteI32(_iter69);
      oprot.WriteI32(Newmap[_iter69]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Newstring) then
  begin
    field_.Name := 'newstring';
    field_.Type_  := {TType.}String_;
    field_.ID := 11;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Newstring);
    oprot.WriteFieldEnd();
  end;
  if (__isset_End_in_both) then
  begin
    field_.Name := 'end_in_both';
    field_.Type_  := {TType.}I32;
    field_.ID := 12;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(End_in_both);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TVersioningTestV2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Begin_in_both: ');
    sb.Append(Begin_in_both);
    sb.Append(',Newint: ');
    sb.Append(Newint);
    sb.Append(',Newbyte: ');
    sb.Append(Newbyte);
    sb.Append(',Newshort: ');
    sb.Append(Newshort);
    sb.Append(',Newlong: ');
    sb.Append(Newlong);
    sb.Append(',Newdouble: ');
    sb.Append(Newdouble);
    sb.Append(',Newstruct: ');
    if (Newstruct = nil) then sb.Append('<null>') else sb.Append(Newstruct.ToString());
    sb.Append(',Newlist: ');
    sb.Append(Newlist);
    sb.Append(',Newset: ');
    sb.Append(Newset);
    sb.Append(',Newmap: ');
    sb.Append(Newmap);
    sb.Append(',Newstring: ');
    sb.Append(Newstring);
    sb.Append(',End_in_both: ');
    sb.Append(End_in_both);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TListTypeVersioningV1Impl.Create;
begin
  inherited;
end;

destructor TListTypeVersioningV1Impl.Destroy;
begin
  inherited;
end;

function TListTypeVersioningV1Impl.GetMyints: IThriftList_V;
begin
  Result := FMyints;
end;

procedure TListTypeVersioningV1Impl.SetMyints( const Value: IThriftList_V);
begin
  F__isset_Myints := True;
  FMyints := Value;
end;

function TListTypeVersioningV1Impl.Get__isset_Myints: Boolean;
begin
  Result := F__isset_Myints;
end;

function TListTypeVersioningV1Impl.GetHello: string;
begin
  Result := FHello;
end;

procedure TListTypeVersioningV1Impl.SetHello( const Value: string);
begin
  F__isset_Hello := True;
  FHello := Value;
end;

function TListTypeVersioningV1Impl.Get__isset_Hello: Boolean;
begin
  Result := F__isset_Hello;
end;

procedure TListTypeVersioningV1Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list70: IList;
  _i71: Integer;
  _elem72: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Myints := TThriftList_VImpl.Create;
            _list70 := iprot.ReadListBegin();
            for _i71 := 0 to _list70.Count - 1 do
            begin
              _elem72 := iprot.ReadI32();
              Myints.Add(_elem72);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Hello := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TListTypeVersioningV1Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_73 : IList;
  _iter74: Integer;
begin
  struc := TStructImpl.Create('ListTypeVersioningV1');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Myints <> nil) and __isset_Myints then
  begin
    field_.Name := 'myints';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_73 := TListImpl.Create({TType.}I32, Myints.Count);
    oprot.WriteListBegin( list_73);
    for _iter74 in Myints do
    begin
      oprot.WriteI32(_iter74);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Hello) then
  begin
    field_.Name := 'hello';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Hello);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TListTypeVersioningV1Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Myints: ');
    sb.Append(Myints);
    sb.Append(',Hello: ');
    sb.Append(Hello);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TListTypeVersioningV2Impl.Create;
begin
  inherited;
end;

destructor TListTypeVersioningV2Impl.Destroy;
begin
  inherited;
end;

function TListTypeVersioningV2Impl.GetStrings: IThriftList_V;
begin
  Result := FStrings;
end;

procedure TListTypeVersioningV2Impl.SetStrings( const Value: IThriftList_V);
begin
  F__isset_Strings := True;
  FStrings := Value;
end;

function TListTypeVersioningV2Impl.Get__isset_Strings: Boolean;
begin
  Result := F__isset_Strings;
end;

function TListTypeVersioningV2Impl.GetHello: string;
begin
  Result := FHello;
end;

procedure TListTypeVersioningV2Impl.SetHello( const Value: string);
begin
  F__isset_Hello := True;
  FHello := Value;
end;

function TListTypeVersioningV2Impl.Get__isset_Hello: Boolean;
begin
  Result := F__isset_Hello;
end;

procedure TListTypeVersioningV2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list75: IList;
  _i76: Integer;
  _elem77: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Strings := TThriftList_VImpl.Create;
            _list75 := iprot.ReadListBegin();
            for _i76 := 0 to _list75.Count - 1 do
            begin
              _elem77 := iprot.ReadString();
              Strings.Add(_elem77);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Hello := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TListTypeVersioningV2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_78 : IList;
  _iter79: string;
begin
  struc := TStructImpl.Create('ListTypeVersioningV2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Strings <> nil) and __isset_Strings then
  begin
    field_.Name := 'strings';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_78 := TListImpl.Create({TType.}String_, Strings.Count);
    oprot.WriteListBegin( list_78);
    for _iter79 in Strings do
    begin
      oprot.WriteString(_iter79);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Hello) then
  begin
    field_.Name := 'hello';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Hello);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TListTypeVersioningV2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Strings: ');
    sb.Append(Strings);
    sb.Append(',Hello: ');
    sb.Append(Hello);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TGuessProtocolStructImpl.Create;
begin
  inherited;
end;

destructor TGuessProtocolStructImpl.Destroy;
begin
  inherited;
end;

function TGuessProtocolStructImpl.GetMap_field: IThriftDictionary_V_V;
begin
  Result := FMap_field;
end;

procedure TGuessProtocolStructImpl.SetMap_field( const Value: IThriftDictionary_V_V);
begin
  F__isset_Map_field := True;
  FMap_field := Value;
end;

function TGuessProtocolStructImpl.Get__isset_Map_field: Boolean;
begin
  Result := F__isset_Map_field;
end;

procedure TGuessProtocolStructImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map80: IMap;
  _i81: Integer;
  _key82: string;
  _val83: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        7: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Map_field := TThriftDictionary_V_VImpl.Create;
            _map80 := iprot.ReadMapBegin();
            for _i81 := 0 to _map80.Count - 1 do
            begin
              _key82 := iprot.ReadString();
              _val83 := iprot.ReadString();
              Map_field.AddOrSetValue( _key82, _val83);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TGuessProtocolStructImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map84 : IMap;
  _iter85: string;
begin
  struc := TStructImpl.Create('GuessProtocolStruct');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Map_field <> nil) and __isset_Map_field then
  begin
    field_.Name := 'map_field';
    field_.Type_  := {TType.}Map;
    field_.ID := 7;
    oprot.WriteFieldBegin(field_);
    map84 := TMapImpl.Create( {TType.}String_, {TType.}String_, Map_field.Count);
    oprot.WriteMapBegin( map84);
    for _iter85 in Map_field.Keys do
    begin
      oprot.WriteString(_iter85);
      oprot.WriteString(Map_field[_iter85]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TGuessProtocolStructImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Map_field: ');
    sb.Append(Map_field);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TLargeDeltasImpl.Create;
begin
  inherited;
end;

destructor TLargeDeltasImpl.Destroy;
begin
  inherited;
end;

function TLargeDeltasImpl.GetB1: IBools;
begin
  Result := FB1;
end;

procedure TLargeDeltasImpl.SetB1( const Value: IBools);
begin
  F__isset_B1 := True;
  FB1 := Value;
end;

function TLargeDeltasImpl.Get__isset_B1: Boolean;
begin
  Result := F__isset_B1;
end;

function TLargeDeltasImpl.GetB10: IBools;
begin
  Result := FB10;
end;

procedure TLargeDeltasImpl.SetB10( const Value: IBools);
begin
  F__isset_B10 := True;
  FB10 := Value;
end;

function TLargeDeltasImpl.Get__isset_B10: Boolean;
begin
  Result := F__isset_B10;
end;

function TLargeDeltasImpl.GetB100: IBools;
begin
  Result := FB100;
end;

procedure TLargeDeltasImpl.SetB100( const Value: IBools);
begin
  F__isset_B100 := True;
  FB100 := Value;
end;

function TLargeDeltasImpl.Get__isset_B100: Boolean;
begin
  Result := F__isset_B100;
end;

function TLargeDeltasImpl.GetCheck_true: Boolean;
begin
  Result := FCheck_true;
end;

procedure TLargeDeltasImpl.SetCheck_true( const Value: Boolean);
begin
  F__isset_Check_true := True;
  FCheck_true := Value;
end;

function TLargeDeltasImpl.Get__isset_Check_true: Boolean;
begin
  Result := F__isset_Check_true;
end;

function TLargeDeltasImpl.GetB1000: IBools;
begin
  Result := FB1000;
end;

procedure TLargeDeltasImpl.SetB1000( const Value: IBools);
begin
  F__isset_B1000 := True;
  FB1000 := Value;
end;

function TLargeDeltasImpl.Get__isset_B1000: Boolean;
begin
  Result := F__isset_B1000;
end;

function TLargeDeltasImpl.GetCheck_false: Boolean;
begin
  Result := FCheck_false;
end;

procedure TLargeDeltasImpl.SetCheck_false( const Value: Boolean);
begin
  F__isset_Check_false := True;
  FCheck_false := Value;
end;

function TLargeDeltasImpl.Get__isset_Check_false: Boolean;
begin
  Result := F__isset_Check_false;
end;

function TLargeDeltasImpl.GetVertwo2000: IVersioningTestV2;
begin
  Result := FVertwo2000;
end;

procedure TLargeDeltasImpl.SetVertwo2000( const Value: IVersioningTestV2);
begin
  F__isset_Vertwo2000 := True;
  FVertwo2000 := Value;
end;

function TLargeDeltasImpl.Get__isset_Vertwo2000: Boolean;
begin
  Result := F__isset_Vertwo2000;
end;

function TLargeDeltasImpl.GetA_set2500: IHashSet_V;
begin
  Result := FA_set2500;
end;

procedure TLargeDeltasImpl.SetA_set2500( const Value: IHashSet_V);
begin
  F__isset_A_set2500 := True;
  FA_set2500 := Value;
end;

function TLargeDeltasImpl.Get__isset_A_set2500: Boolean;
begin
  Result := F__isset_A_set2500;
end;

function TLargeDeltasImpl.GetVertwo3000: IVersioningTestV2;
begin
  Result := FVertwo3000;
end;

procedure TLargeDeltasImpl.SetVertwo3000( const Value: IVersioningTestV2);
begin
  F__isset_Vertwo3000 := True;
  FVertwo3000 := Value;
end;

function TLargeDeltasImpl.Get__isset_Vertwo3000: Boolean;
begin
  Result := F__isset_Vertwo3000;
end;

function TLargeDeltasImpl.GetBig_numbers: IThriftList_V;
begin
  Result := FBig_numbers;
end;

procedure TLargeDeltasImpl.SetBig_numbers( const Value: IThriftList_V);
begin
  F__isset_Big_numbers := True;
  FBig_numbers := Value;
end;

function TLargeDeltasImpl.Get__isset_Big_numbers: Boolean;
begin
  Result := F__isset_Big_numbers;
end;

procedure TLargeDeltasImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set86: ISet;
  _i87: Integer;
  _elem88: string;
  _list89: IList;
  _i90: Integer;
  _elem91: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B1 := TBoolsImpl.Create;
            B1.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        10: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B10 := TBoolsImpl.Create;
            B10.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        100: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B100 := TBoolsImpl.Create;
            B100.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        500: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Check_true := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1000: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            B1000 := TBoolsImpl.Create;
            B1000.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1500: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            Check_false := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2000: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Vertwo2000 := TVersioningTestV2Impl.Create;
            Vertwo2000.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2500: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            A_set2500 := THashSet_VImpl.Create;
            _set86 := iprot.ReadSetBegin();
            for _i87 := 0 to _set86.Count - 1 do
            begin
              _elem88 := iprot.ReadString();
              A_set2500.Add(_elem88);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3000: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Vertwo3000 := TVersioningTestV2Impl.Create;
            Vertwo3000.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4000: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Big_numbers := TThriftList_VImpl.Create;
            _list89 := iprot.ReadListBegin();
            for _i90 := 0 to _list89.Count - 1 do
            begin
              _elem91 := iprot.ReadI32();
              Big_numbers.Add(_elem91);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TLargeDeltasImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_92 : ISet;
  _iter93: string;
  list_94 : IList;
  _iter95: Integer;
begin
  struc := TStructImpl.Create('LargeDeltas');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (B1 <> nil) and __isset_B1 then
  begin
    field_.Name := 'b1';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    B1.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (B10 <> nil) and __isset_B10 then
  begin
    field_.Name := 'b10';
    field_.Type_  := {TType.}Struct;
    field_.ID := 10;
    oprot.WriteFieldBegin(field_);
    B10.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (B100 <> nil) and __isset_B100 then
  begin
    field_.Name := 'b100';
    field_.Type_  := {TType.}Struct;
    field_.ID := 100;
    oprot.WriteFieldBegin(field_);
    B100.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Check_true) then
  begin
    field_.Name := 'check_true';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 500;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Check_true);
    oprot.WriteFieldEnd();
  end;
  if (B1000 <> nil) and __isset_B1000 then
  begin
    field_.Name := 'b1000';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1000;
    oprot.WriteFieldBegin(field_);
    B1000.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Check_false) then
  begin
    field_.Name := 'check_false';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 1500;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(Check_false);
    oprot.WriteFieldEnd();
  end;
  if (Vertwo2000 <> nil) and __isset_Vertwo2000 then
  begin
    field_.Name := 'vertwo2000';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2000;
    oprot.WriteFieldBegin(field_);
    Vertwo2000.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (A_set2500 <> nil) and __isset_A_set2500 then
  begin
    field_.Name := 'a_set2500';
    field_.Type_  := {TType.}Set_;
    field_.ID := 2500;
    oprot.WriteFieldBegin(field_);
    set_92 := TSetImpl.Create({TType.}String_, A_set2500.Count);
    oprot.WriteSetBegin( set_92);
    for _iter93 in A_set2500 do
    begin
      oprot.WriteString(_iter93);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  if (Vertwo3000 <> nil) and __isset_Vertwo3000 then
  begin
    field_.Name := 'vertwo3000';
    field_.Type_  := {TType.}Struct;
    field_.ID := 3000;
    oprot.WriteFieldBegin(field_);
    Vertwo3000.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Big_numbers <> nil) and __isset_Big_numbers then
  begin
    field_.Name := 'big_numbers';
    field_.Type_  := {TType.}List;
    field_.ID := 4000;
    oprot.WriteFieldBegin(field_);
    list_94 := TListImpl.Create({TType.}I32, Big_numbers.Count);
    oprot.WriteListBegin( list_94);
    for _iter95 in Big_numbers do
    begin
      oprot.WriteI32(_iter95);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TLargeDeltasImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('B1: ');
    if (B1 = nil) then sb.Append('<null>') else sb.Append(B1.ToString());
    sb.Append(',B10: ');
    if (B10 = nil) then sb.Append('<null>') else sb.Append(B10.ToString());
    sb.Append(',B100: ');
    if (B100 = nil) then sb.Append('<null>') else sb.Append(B100.ToString());
    sb.Append(',Check_true: ');
    sb.Append(Check_true);
    sb.Append(',B1000: ');
    if (B1000 = nil) then sb.Append('<null>') else sb.Append(B1000.ToString());
    sb.Append(',Check_false: ');
    sb.Append(Check_false);
    sb.Append(',Vertwo2000: ');
    if (Vertwo2000 = nil) then sb.Append('<null>') else sb.Append(Vertwo2000.ToString());
    sb.Append(',A_set2500: ');
    sb.Append(A_set2500);
    sb.Append(',Vertwo3000: ');
    if (Vertwo3000 = nil) then sb.Append('<null>') else sb.Append(Vertwo3000.ToString());
    sb.Append(',Big_numbers: ');
    sb.Append(Big_numbers);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedListsI32x2Impl.Create;
begin
  inherited;
end;

destructor TNestedListsI32x2Impl.Destroy;
begin
  inherited;
end;

function TNestedListsI32x2Impl.GetIntegerlist: IThriftList_V;
begin
  Result := FIntegerlist;
end;

procedure TNestedListsI32x2Impl.SetIntegerlist( const Value: IThriftList_V);
begin
  F__isset_Integerlist := True;
  FIntegerlist := Value;
end;

function TNestedListsI32x2Impl.Get__isset_Integerlist: Boolean;
begin
  Result := F__isset_Integerlist;
end;

procedure TNestedListsI32x2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list96: IList;
  _i97: Integer;
  _elem98: IThriftList_V;
  _list99: IList;
  _i100: Integer;
  _elem101: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Integerlist := TThriftList_VImpl.Create;
            _list96 := iprot.ReadListBegin();
            for _i97 := 0 to _list96.Count - 1 do
            begin
              _elem98 := TThriftList_VImpl.Create;
              _list99 := iprot.ReadListBegin();
              for _i100 := 0 to _list99.Count - 1 do
              begin
                _elem101 := iprot.ReadI32();
                _elem98.Add(_elem101);
              end;
              iprot.ReadListEnd();
              Integerlist.Add(_elem98);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedListsI32x2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_102 : IList;
  _iter103: IThriftList_V;
  list_104 : IList;
  _iter105: Integer;
begin
  struc := TStructImpl.Create('NestedListsI32x2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Integerlist <> nil) and __isset_Integerlist then
  begin
    field_.Name := 'integerlist';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_102 := TListImpl.Create({TType.}List, Integerlist.Count);
    oprot.WriteListBegin( list_102);
    for _iter103 in Integerlist do
    begin
      list_104 := TListImpl.Create({TType.}I32, _iter103.Count);
      oprot.WriteListBegin( list_104);
      for _iter105 in _iter103 do
      begin
        oprot.WriteI32(_iter105);
      end;
      oprot.WriteListEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedListsI32x2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Integerlist: ');
    sb.Append(Integerlist);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedListsI32x3Impl.Create;
begin
  inherited;
end;

destructor TNestedListsI32x3Impl.Destroy;
begin
  inherited;
end;

function TNestedListsI32x3Impl.GetIntegerlist: IThriftList_V;
begin
  Result := FIntegerlist;
end;

procedure TNestedListsI32x3Impl.SetIntegerlist( const Value: IThriftList_V);
begin
  F__isset_Integerlist := True;
  FIntegerlist := Value;
end;

function TNestedListsI32x3Impl.Get__isset_Integerlist: Boolean;
begin
  Result := F__isset_Integerlist;
end;

procedure TNestedListsI32x3Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list106: IList;
  _i107: Integer;
  _elem108: IThriftList_V;
  _list109: IList;
  _i110: Integer;
  _elem111: IThriftList_V;
  _list112: IList;
  _i113: Integer;
  _elem114: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Integerlist := TThriftList_VImpl.Create;
            _list106 := iprot.ReadListBegin();
            for _i107 := 0 to _list106.Count - 1 do
            begin
              _elem108 := TThriftList_VImpl.Create;
              _list109 := iprot.ReadListBegin();
              for _i110 := 0 to _list109.Count - 1 do
              begin
                _elem111 := TThriftList_VImpl.Create;
                _list112 := iprot.ReadListBegin();
                for _i113 := 0 to _list112.Count - 1 do
                begin
                  _elem114 := iprot.ReadI32();
                  _elem111.Add(_elem114);
                end;
                iprot.ReadListEnd();
                _elem108.Add(_elem111);
              end;
              iprot.ReadListEnd();
              Integerlist.Add(_elem108);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedListsI32x3Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_115 : IList;
  _iter116: IThriftList_V;
  list_117 : IList;
  _iter118: IThriftList_V;
  list_119 : IList;
  _iter120: Integer;
begin
  struc := TStructImpl.Create('NestedListsI32x3');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Integerlist <> nil) and __isset_Integerlist then
  begin
    field_.Name := 'integerlist';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_115 := TListImpl.Create({TType.}List, Integerlist.Count);
    oprot.WriteListBegin( list_115);
    for _iter116 in Integerlist do
    begin
      list_117 := TListImpl.Create({TType.}List, _iter116.Count);
      oprot.WriteListBegin( list_117);
      for _iter118 in _iter116 do
      begin
        list_119 := TListImpl.Create({TType.}I32, _iter118.Count);
        oprot.WriteListBegin( list_119);
        for _iter120 in _iter118 do
        begin
          oprot.WriteI32(_iter120);
        end;
        oprot.WriteListEnd();
      end;
      oprot.WriteListEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedListsI32x3Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Integerlist: ');
    sb.Append(Integerlist);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedMixedx2Impl.Create;
begin
  inherited;
end;

destructor TNestedMixedx2Impl.Destroy;
begin
  inherited;
end;

function TNestedMixedx2Impl.GetInt_set_list: IThriftList_V;
begin
  Result := FInt_set_list;
end;

procedure TNestedMixedx2Impl.SetInt_set_list( const Value: IThriftList_V);
begin
  F__isset_Int_set_list := True;
  FInt_set_list := Value;
end;

function TNestedMixedx2Impl.Get__isset_Int_set_list: Boolean;
begin
  Result := F__isset_Int_set_list;
end;

function TNestedMixedx2Impl.GetMap_int_strset: IThriftDictionary_V_V;
begin
  Result := FMap_int_strset;
end;

procedure TNestedMixedx2Impl.SetMap_int_strset( const Value: IThriftDictionary_V_V);
begin
  F__isset_Map_int_strset := True;
  FMap_int_strset := Value;
end;

function TNestedMixedx2Impl.Get__isset_Map_int_strset: Boolean;
begin
  Result := F__isset_Map_int_strset;
end;

function TNestedMixedx2Impl.GetMap_int_strset_list: IThriftList_V;
begin
  Result := FMap_int_strset_list;
end;

procedure TNestedMixedx2Impl.SetMap_int_strset_list( const Value: IThriftList_V);
begin
  F__isset_Map_int_strset_list := True;
  FMap_int_strset_list := Value;
end;

function TNestedMixedx2Impl.Get__isset_Map_int_strset_list: Boolean;
begin
  Result := F__isset_Map_int_strset_list;
end;

procedure TNestedMixedx2Impl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list121: IList;
  _i122: Integer;
  _elem123: IHashSet_V;
  _set124: ISet;
  _i125: Integer;
  _elem126: Integer;
  _map127: IMap;
  _i128: Integer;
  _key129: Integer;
  _val130: IHashSet_V;
  _set131: ISet;
  _i132: Integer;
  _elem133: string;
  _list134: IList;
  _i135: Integer;
  _elem136: IThriftDictionary_V_V;
  _map137: IMap;
  _i138: Integer;
  _key139: Integer;
  _val140: IHashSet_V;
  _set141: ISet;
  _i142: Integer;
  _elem143: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Int_set_list := TThriftList_VImpl.Create;
            _list121 := iprot.ReadListBegin();
            for _i122 := 0 to _list121.Count - 1 do
            begin
              _elem123 := THashSet_VImpl.Create;
              _set124 := iprot.ReadSetBegin();
              for _i125 := 0 to _set124.Count - 1 do
              begin
                _elem126 := iprot.ReadI32();
                _elem123.Add(_elem126);
              end;
              iprot.ReadSetEnd();
              Int_set_list.Add(_elem123);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Map_int_strset := TThriftDictionary_V_VImpl.Create;
            _map127 := iprot.ReadMapBegin();
            for _i128 := 0 to _map127.Count - 1 do
            begin
              _key129 := iprot.ReadI32();
              _val130 := THashSet_VImpl.Create;
              _set131 := iprot.ReadSetBegin();
              for _i132 := 0 to _set131.Count - 1 do
              begin
                _elem133 := iprot.ReadString();
                _val130.Add(_elem133);
              end;
              iprot.ReadSetEnd();
              Map_int_strset.AddOrSetValue( _key129, _val130);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Map_int_strset_list := TThriftList_VImpl.Create;
            _list134 := iprot.ReadListBegin();
            for _i135 := 0 to _list134.Count - 1 do
            begin
              _elem136 := TThriftDictionary_V_VImpl.Create;
              _map137 := iprot.ReadMapBegin();
              for _i138 := 0 to _map137.Count - 1 do
              begin
                _key139 := iprot.ReadI32();
                _val140 := THashSet_VImpl.Create;
                _set141 := iprot.ReadSetBegin();
                for _i142 := 0 to _set141.Count - 1 do
                begin
                  _elem143 := iprot.ReadString();
                  _val140.Add(_elem143);
                end;
                iprot.ReadSetEnd();
                _elem136.AddOrSetValue( _key139, _val140);
              end;
              iprot.ReadMapEnd();
              Map_int_strset_list.Add(_elem136);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedMixedx2Impl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_144 : IList;
  _iter145: IHashSet_V;
  set_146 : ISet;
  _iter147: Integer;
  map148 : IMap;
  _iter149: Integer;
  set_150 : ISet;
  _iter151: string;
  list_152 : IList;
  _iter153: IThriftDictionary_V_V;
  map154 : IMap;
  _iter155: Integer;
  set_156 : ISet;
  _iter157: string;
begin
  struc := TStructImpl.Create('NestedMixedx2');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Int_set_list <> nil) and __isset_Int_set_list then
  begin
    field_.Name := 'int_set_list';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_144 := TListImpl.Create({TType.}Set_, Int_set_list.Count);
    oprot.WriteListBegin( list_144);
    for _iter145 in Int_set_list do
    begin
      set_146 := TSetImpl.Create({TType.}I32, _iter145.Count);
      oprot.WriteSetBegin( set_146);
      for _iter147 in _iter145 do
      begin
        oprot.WriteI32(_iter147);
      end;
      oprot.WriteSetEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  if (Map_int_strset <> nil) and __isset_Map_int_strset then
  begin
    field_.Name := 'map_int_strset';
    field_.Type_  := {TType.}Map;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    map148 := TMapImpl.Create( {TType.}I32, {TType.}Set_, Map_int_strset.Count);
    oprot.WriteMapBegin( map148);
    for _iter149 in Map_int_strset.Keys do
    begin
      oprot.WriteI32(_iter149);
      set_150 := TSetImpl.Create({TType.}String_, Map_int_strset[_iter149].Count);
      oprot.WriteSetBegin( set_150);
      for _iter151 in Map_int_strset[_iter149] do
      begin
        oprot.WriteString(_iter151);
      end;
      oprot.WriteSetEnd();
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (Map_int_strset_list <> nil) and __isset_Map_int_strset_list then
  begin
    field_.Name := 'map_int_strset_list';
    field_.Type_  := {TType.}List;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    list_152 := TListImpl.Create({TType.}Map, Map_int_strset_list.Count);
    oprot.WriteListBegin( list_152);
    for _iter153 in Map_int_strset_list do
    begin
      map154 := TMapImpl.Create( {TType.}I32, {TType.}Set_, _iter153.Count);
      oprot.WriteMapBegin( map154);
      for _iter155 in _iter153.Keys do
      begin
        oprot.WriteI32(_iter155);
        set_156 := TSetImpl.Create({TType.}String_, _iter153[_iter155].Count);
        oprot.WriteSetBegin( set_156);
        for _iter157 in _iter153[_iter155] do
        begin
          oprot.WriteString(_iter157);
        end;
        oprot.WriteSetEnd();
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedMixedx2Impl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Int_set_list: ');
    sb.Append(Int_set_list);
    sb.Append(',Map_int_strset: ');
    sb.Append(Map_int_strset);
    sb.Append(',Map_int_strset_list: ');
    sb.Append(Map_int_strset_list);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TListBonksImpl.Create;
begin
  inherited;
end;

destructor TListBonksImpl.Destroy;
begin
  inherited;
end;

function TListBonksImpl.GetBonk: IThriftList_V;
begin
  Result := FBonk;
end;

procedure TListBonksImpl.SetBonk( const Value: IThriftList_V);
begin
  F__isset_Bonk := True;
  FBonk := Value;
end;

function TListBonksImpl.Get__isset_Bonk: Boolean;
begin
  Result := F__isset_Bonk;
end;

procedure TListBonksImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list158: IList;
  _i159: Integer;
  _elem160: IBonk;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Bonk := TThriftList_VImpl.Create;
            _list158 := iprot.ReadListBegin();
            for _i159 := 0 to _list158.Count - 1 do
            begin
              _elem160 := TBonkImpl.Create;
              _elem160.Read(iprot);
              Bonk.Add(_elem160);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TListBonksImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_161 : IList;
  _iter162: IBonk;
begin
  struc := TStructImpl.Create('ListBonks');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Bonk <> nil) and __isset_Bonk then
  begin
    field_.Name := 'bonk';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_161 := TListImpl.Create({TType.}Struct, Bonk.Count);
    oprot.WriteListBegin( list_161);
    for _iter162 in Bonk do
    begin
      _iter162.Write(oprot);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TListBonksImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Bonk: ');
    sb.Append(Bonk);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TNestedListsBonkImpl.Create;
begin
  inherited;
end;

destructor TNestedListsBonkImpl.Destroy;
begin
  inherited;
end;

function TNestedListsBonkImpl.GetBonk: IThriftList_V;
begin
  Result := FBonk;
end;

procedure TNestedListsBonkImpl.SetBonk( const Value: IThriftList_V);
begin
  F__isset_Bonk := True;
  FBonk := Value;
end;

function TNestedListsBonkImpl.Get__isset_Bonk: Boolean;
begin
  Result := F__isset_Bonk;
end;

procedure TNestedListsBonkImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list163: IList;
  _i164: Integer;
  _elem165: IThriftList_V;
  _list166: IList;
  _i167: Integer;
  _elem168: IThriftList_V;
  _list169: IList;
  _i170: Integer;
  _elem171: IBonk;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Bonk := TThriftList_VImpl.Create;
            _list163 := iprot.ReadListBegin();
            for _i164 := 0 to _list163.Count - 1 do
            begin
              _elem165 := TThriftList_VImpl.Create;
              _list166 := iprot.ReadListBegin();
              for _i167 := 0 to _list166.Count - 1 do
              begin
                _elem168 := TThriftList_VImpl.Create;
                _list169 := iprot.ReadListBegin();
                for _i170 := 0 to _list169.Count - 1 do
                begin
                  _elem171 := TBonkImpl.Create;
                  _elem171.Read(iprot);
                  _elem168.Add(_elem171);
                end;
                iprot.ReadListEnd();
                _elem165.Add(_elem168);
              end;
              iprot.ReadListEnd();
              Bonk.Add(_elem165);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TNestedListsBonkImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_172 : IList;
  _iter173: IThriftList_V;
  list_174 : IList;
  _iter175: IThriftList_V;
  list_176 : IList;
  _iter177: IBonk;
begin
  struc := TStructImpl.Create('NestedListsBonk');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Bonk <> nil) and __isset_Bonk then
  begin
    field_.Name := 'bonk';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_172 := TListImpl.Create({TType.}List, Bonk.Count);
    oprot.WriteListBegin( list_172);
    for _iter173 in Bonk do
    begin
      list_174 := TListImpl.Create({TType.}List, _iter173.Count);
      oprot.WriteListBegin( list_174);
      for _iter175 in _iter173 do
      begin
        list_176 := TListImpl.Create({TType.}Struct, _iter175.Count);
        oprot.WriteListBegin( list_176);
        for _iter177 in _iter175 do
        begin
          _iter177.Write(oprot);
        end;
        oprot.WriteListEnd();
      end;
      oprot.WriteListEnd();
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TNestedListsBonkImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Bonk: ');
    sb.Append(Bonk);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TBoolTestImpl.Create;
begin
  inherited;
  FB := True;
  F__isset_B := True;
  FS := 'true';
  F__isset_S := True;
end;

destructor TBoolTestImpl.Destroy;
begin
  inherited;
end;

function TBoolTestImpl.GetB: Boolean;
begin
  Result := FB;
end;

procedure TBoolTestImpl.SetB( const Value: Boolean);
begin
  F__isset_B := True;
  FB := Value;
end;

function TBoolTestImpl.Get__isset_B: Boolean;
begin
  Result := F__isset_B;
end;

function TBoolTestImpl.GetS: string;
begin
  Result := FS;
end;

procedure TBoolTestImpl.SetS( const Value: string);
begin
  F__isset_S := True;
  FS := Value;
end;

function TBoolTestImpl.Get__isset_S: Boolean;
begin
  Result := F__isset_S;
end;

procedure TBoolTestImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Bool_) then
          begin
            B := iprot.ReadBool();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            S := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TBoolTestImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('BoolTest');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_B) then
  begin
    field_.Name := 'b';
    field_.Type_  := {TType.}Bool_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteBool(B);
    oprot.WriteFieldEnd();
  end;
  if (__isset_S) then
  begin
    field_.Name := 's';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(S);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TBoolTestImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('B: ');
    sb.Append(B);
    sb.Append(',S: ');
    sb.Append(S);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TStructAImpl.Create;
begin
  inherited;
end;

destructor TStructAImpl.Destroy;
begin
  inherited;
end;

function TStructAImpl.GetS: string;
begin
  Result := FS;
end;

procedure TStructAImpl.SetS( const Value: string);
begin
  FS := Value;
end;

procedure TStructAImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _req_isset_S : Boolean;

begin
  _req_isset_S := FALSE;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            S := iprot.ReadString();
            _req_isset_S := TRUE;
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
  if not _req_isset_S
  then raise TProtocolException.Create( TProtocolException.INVALID_DATA, 'S');
end;

procedure TStructAImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('StructA');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  // required field
  field_.Name := 's';
  field_.Type_  := {TType.}String_;
  field_.ID := 1;
  oprot.WriteFieldBegin(field_);
  oprot.WriteString(S);
  oprot.WriteFieldEnd();
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TStructAImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('S: ');
    sb.Append(S);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TStructBImpl.Create;
begin
  inherited;
end;

destructor TStructBImpl.Destroy;
begin
  inherited;
end;

function TStructBImpl.GetAa: IStructA;
begin
  Result := FAa;
end;

procedure TStructBImpl.SetAa( const Value: IStructA);
begin
  F__isset_Aa := True;
  FAa := Value;
end;

function TStructBImpl.Get__isset_Aa: Boolean;
begin
  Result := F__isset_Aa;
end;

function TStructBImpl.GetAb: IStructA;
begin
  Result := FAb;
end;

procedure TStructBImpl.SetAb( const Value: IStructA);
begin
  FAb := Value;
end;

procedure TStructBImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _req_isset_Ab : Boolean;

begin
  _req_isset_Ab := FALSE;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Aa := TStructAImpl.Create;
            Aa.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Ab := TStructAImpl.Create;
            Ab.Read(iprot);
            _req_isset_Ab := TRUE;
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
  if not _req_isset_Ab
  then raise TProtocolException.Create( TProtocolException.INVALID_DATA, 'Ab');
end;

procedure TStructBImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('StructB');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Aa <> nil) and __isset_Aa then
  begin
    field_.Name := 'aa';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Aa.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Ab <> nil) then
  begin
    field_.Name := 'ab';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Ab.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TStructBImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Aa: ');
    if (Aa = nil) then sb.Append('<null>') else sb.Append(Aa.ToString());
    sb.Append(',Ab: ');
    if (Ab = nil) then sb.Append('<null>') else sb.Append(Ab.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TThriftTest.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  iprot_ := iprot;
  oprot_ := oprot;
end;

procedure TThriftTest.TClient.testVoid();
begin
  send_testVoid();
  recv_testVoid();
end;

procedure TThriftTest.TClient.send_testVoid();
var
  args : ITestVoid_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testVoid', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestVoid_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TThriftTest.TClient.recv_testVoid();
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestVoid_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestVoid_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

function TThriftTest.TClient.testString(const thing: string): string;
begin
  send_testString(thing);
  Result := recv_testString();
end;

procedure TThriftTest.TClient.send_testString(const thing: string);
var
  args : ITestString_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testString', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestString_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := '';
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testString(): string;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestString_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestString_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testString failed: unknown result');
end;

function TThriftTest.TClient.testByte(thing: ShortInt): ShortInt;
begin
  send_testByte(thing);
  Result := recv_testByte();
end;

procedure TThriftTest.TClient.send_testByte(thing: ShortInt);
var
  args : ITestByte_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testByte', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestByte_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testByte(): ShortInt;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestByte_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestByte_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testByte failed: unknown result');
end;

function TThriftTest.TClient.testI32(thing: Integer): Integer;
begin
  send_testI32(thing);
  Result := recv_testI32();
end;

procedure TThriftTest.TClient.send_testI32(thing: Integer);
var
  args : ITestI32_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testI32', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestI32_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testI32(): Integer;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestI32_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestI32_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testI32 failed: unknown result');
end;

function TThriftTest.TClient.testI64(const thing: Int64): Int64;
begin
  send_testI64(thing);
  Result := recv_testI64();
end;

procedure TThriftTest.TClient.send_testI64(const thing: Int64);
var
  args : ITestI64_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testI64', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestI64_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testI64(): Int64;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestI64_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestI64_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testI64 failed: unknown result');
end;

function TThriftTest.TClient.testDouble(const thing: Double): Double;
begin
  send_testDouble(thing);
  Result := recv_testDouble();
end;

procedure TThriftTest.TClient.send_testDouble(const thing: Double);
var
  args : ITestDouble_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testDouble', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestDouble_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0.0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testDouble(): Double;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestDouble_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestDouble_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testDouble failed: unknown result');
end;

function TThriftTest.TClient.testStruct(const thing: IXtruct): IXtruct;
begin
  send_testStruct(thing);
  Result := recv_testStruct();
end;

procedure TThriftTest.TClient.send_testStruct(const thing: IXtruct);
var
  args : ITestStruct_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testStruct', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestStruct_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testStruct(): IXtruct;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestStruct_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestStruct_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testStruct failed: unknown result');
end;

function TThriftTest.TClient.testNest(const thing: IXtruct2): IXtruct2;
begin
  send_testNest(thing);
  Result := recv_testNest();
end;

procedure TThriftTest.TClient.send_testNest(const thing: IXtruct2);
var
  args : ITestNest_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testNest', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestNest_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testNest(): IXtruct2;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestNest_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestNest_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testNest failed: unknown result');
end;

function TThriftTest.TClient.testMap(const thing: IThriftDictionary_V_V): IThriftDictionary_V_V;
begin
  send_testMap(thing);
  Result := recv_testMap();
end;

procedure TThriftTest.TClient.send_testMap(const thing: IThriftDictionary_V_V);
var
  args : ITestMap_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMap', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMap_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMap(): IThriftDictionary_V_V;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestMap_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMap_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMap failed: unknown result');
end;

function TThriftTest.TClient.testStringMap(const thing: IThriftDictionary_V_V): IThriftDictionary_V_V;
begin
  send_testStringMap(thing);
  Result := recv_testStringMap();
end;

procedure TThriftTest.TClient.send_testStringMap(const thing: IThriftDictionary_V_V);
var
  args : ITestStringMap_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testStringMap', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestStringMap_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testStringMap(): IThriftDictionary_V_V;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestStringMap_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestStringMap_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testStringMap failed: unknown result');
end;

function TThriftTest.TClient.testSet(const thing: IHashSet_V): IHashSet_V;
begin
  send_testSet(thing);
  Result := recv_testSet();
end;

procedure TThriftTest.TClient.send_testSet(const thing: IHashSet_V);
var
  args : ITestSet_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testSet', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestSet_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testSet(): IHashSet_V;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestSet_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestSet_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testSet failed: unknown result');
end;

function TThriftTest.TClient.testList(const thing: IThriftList_V): IThriftList_V;
begin
  send_testList(thing);
  Result := recv_testList();
end;

procedure TThriftTest.TClient.send_testList(const thing: IThriftList_V);
var
  args : ITestList_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testList', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestList_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testList(): IThriftList_V;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestList_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestList_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testList failed: unknown result');
end;

function TThriftTest.TClient.testEnum(thing: TNumberz): TNumberz;
begin
  send_testEnum(thing);
  Result := recv_testEnum();
end;

procedure TThriftTest.TClient.send_testEnum(thing: TNumberz);
var
  args : ITestEnum_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testEnum', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestEnum_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := TNumberz(0);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testEnum(): TNumberz;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestEnum_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestEnum_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testEnum failed: unknown result');
end;

function TThriftTest.TClient.testTypedef(const thing: TUserId): TUserId;
begin
  send_testTypedef(thing);
  Result := recv_testTypedef();
end;

procedure TThriftTest.TClient.send_testTypedef(const thing: TUserId);
var
  args : ITestTypedef_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testTypedef', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestTypedef_argsImpl.Create();
  args.Thing := thing;
  args.Write(oprot_);
  args.Thing := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testTypedef(): TUserId;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestTypedef_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestTypedef_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testTypedef failed: unknown result');
end;

function TThriftTest.TClient.testMapMap(hello: Integer): IThriftDictionary_V_V;
begin
  send_testMapMap(hello);
  Result := recv_testMapMap();
end;

procedure TThriftTest.TClient.send_testMapMap(hello: Integer);
var
  args : ITestMapMap_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMapMap', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMapMap_argsImpl.Create();
  args.Hello := hello;
  args.Write(oprot_);
  args.Hello := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMapMap(): IThriftDictionary_V_V;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestMapMap_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMapMap_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMapMap failed: unknown result');
end;

function TThriftTest.TClient.testInsanity(const argument: IInsanity): IThriftDictionary_V_V;
begin
  send_testInsanity(argument);
  Result := recv_testInsanity();
end;

procedure TThriftTest.TClient.send_testInsanity(const argument: IInsanity);
var
  args : ITestInsanity_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testInsanity', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestInsanity_argsImpl.Create();
  args.Argument := argument;
  args.Write(oprot_);
  args.Argument := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testInsanity(): IThriftDictionary_V_V;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestInsanity_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestInsanity_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testInsanity failed: unknown result');
end;

function TThriftTest.TClient.testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary_V_V; arg4: TNumberz; const arg5: TUserId): IXtruct;
begin
  send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5);
  Result := recv_testMulti();
end;

procedure TThriftTest.TClient.send_testMulti(arg0: ShortInt; arg1: Integer; const arg2: Int64; const arg3: IThriftDictionary_V_V; arg4: TNumberz; const arg5: TUserId);
var
  args : ITestMulti_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMulti', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMulti_argsImpl.Create();
  args.Arg0 := arg0;
  args.Arg1 := arg1;
  args.Arg2 := arg2;
  args.Arg3 := arg3;
  args.Arg4 := arg4;
  args.Arg5 := arg5;
  args.Write(oprot_);
  args.Arg0 := 0;
  args.Arg1 := 0;
  args.Arg2 := 0;
  args.Arg3 := nil;
  args.Arg4 := TNumberz(0);
  args.Arg5 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMulti(): IXtruct;
var
  msg : IMessage;
  x : TApplicationException;
  ret : ITestMulti_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMulti_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMulti failed: unknown result');
end;

procedure TThriftTest.TClient.testException(const arg: string);
begin
  send_testException(arg);
  recv_testException();
end;

procedure TThriftTest.TClient.send_testException(const arg: string);
var
  args : ITestException_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testException', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestException_argsImpl.Create();
  args.Arg := arg;
  args.Write(oprot_);
  args.Arg := '';
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TThriftTest.TClient.recv_testException();
var
  msg : IMessage;
  ex : Sysutils.Exception;
  x : TApplicationException;
  ret : ITestException_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestException_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_Err1) then
  begin
    ex := ret.Err1.CreateException;
    raise ex;
  end;
end;

function TThriftTest.TClient.testMultiException(const arg0: string; const arg1: string): IXtruct;
begin
  send_testMultiException(arg0, arg1);
  Result := recv_testMultiException();
end;

procedure TThriftTest.TClient.send_testMultiException(const arg0: string; const arg1: string);
var
  args : ITestMultiException_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testMultiException', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestMultiException_argsImpl.Create();
  args.Arg0 := arg0;
  args.Arg1 := arg1;
  args.Write(oprot_);
  args.Arg0 := '';
  args.Arg1 := '';
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TThriftTest.TClient.recv_testMultiException(): IXtruct;
var
  msg : IMessage;
  ex : Sysutils.Exception;
  x : TApplicationException;
  ret : ITestMultiException_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TTestMultiException_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (ret.__isset_success) then
  begin
    Result := ret.Success;
    ret.Success := nil;
    Exit;
  end;
  if (ret.__isset_Err1) then
  begin
    ex := ret.Err1.CreateException;
    raise ex;
  end;
  if (ret.__isset_Err2) then
  begin
    ex := ret.Err2.CreateException;
    raise ex;
  end;
  raise TApplicationException.Create({TApplicationException.TExceptionType.}MissingResult, 'testMultiException failed: unknown result');
end;

procedure TThriftTest.TClient.testOneway(secondsToSleep: Integer);
begin
  send_testOneway(secondsToSleep);
end;

procedure TThriftTest.TClient.send_testOneway(secondsToSleep: Integer);
var
  args : ITestOneway_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('testOneway', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TTestOneway_argsImpl.Create();
  args.SecondsToSleep := secondsToSleep;
  args.Write(oprot_);
  args.SecondsToSleep := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

constructor TThriftTest.TProcessorImpl.Create( iface_: Iface );
var
tmpmethod:TProcessFunction;
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionary_V_VImpl{<string, TProcessFunction>}.Create;
  //processMap_.AddOrSetValue( 'testVoid', testVoid_Process);
  tmpmethod:=Self.testVoid_Process;
  processMap_.AddOrSetValue( 'testVoid',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testString', testString_Process);
  tmpmethod:=Self.testString_Process;
  processMap_.AddOrSetValue( 'testString',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testByte', testByte_Process);
  tmpmethod:=Self.testByte_Process;
  processMap_.AddOrSetValue( 'testByte',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testI32', testI32_Process);
  tmpmethod:=Self.testI32_Process;
  processMap_.AddOrSetValue( 'testI32',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testI64', testI64_Process);
  tmpmethod:=Self.testI64_Process;
  processMap_.AddOrSetValue( 'testI64',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testDouble', testDouble_Process);
  tmpmethod:=Self.testDouble_Process;
  processMap_.AddOrSetValue( 'testDouble',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testStruct', testStruct_Process);
  tmpmethod:=Self.testStruct_Process;
  processMap_.AddOrSetValue( 'testStruct',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testNest', testNest_Process);
  tmpmethod:=Self.testNest_Process;
  processMap_.AddOrSetValue( 'testNest',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMap', testMap_Process);
  tmpmethod:=Self.testMap_Process;
  processMap_.AddOrSetValue( 'testMap',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testStringMap', testStringMap_Process);
  tmpmethod:=Self.testStringMap_Process;
  processMap_.AddOrSetValue( 'testStringMap',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testSet', testSet_Process);
  tmpmethod:=Self.testSet_Process;
  processMap_.AddOrSetValue( 'testSet',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testList', testList_Process);
  tmpmethod:=Self.testList_Process;
  processMap_.AddOrSetValue( 'testList',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testEnum', testEnum_Process);
  tmpmethod:=Self.testEnum_Process;
  processMap_.AddOrSetValue( 'testEnum',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testTypedef', testTypedef_Process);
  tmpmethod:=Self.testTypedef_Process;
  processMap_.AddOrSetValue( 'testTypedef',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMapMap', testMapMap_Process);
  tmpmethod:=Self.testMapMap_Process;
  processMap_.AddOrSetValue( 'testMapMap',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testInsanity', testInsanity_Process);
  tmpmethod:=Self.testInsanity_Process;
  processMap_.AddOrSetValue( 'testInsanity',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMulti', testMulti_Process);
  tmpmethod:=Self.testMulti_Process;
  processMap_.AddOrSetValue( 'testMulti',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testException', testException_Process);
  tmpmethod:=Self.testException_Process;
  processMap_.AddOrSetValue( 'testException',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testMultiException', testMultiException_Process);
  tmpmethod:=Self.testMultiException_Process;
  processMap_.AddOrSetValue( 'testMultiException',Pointer(@tmpmethod));
  //processMap_.AddOrSetValue( 'testOneway', testOneway_Process);
  tmpmethod:=Self.testOneway_Process;
  processMap_.AddOrSetValue( 'testOneway',Pointer(@tmpmethod));
end;

destructor TThriftTest.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
var
  msg : IMessage;
  fn : TProcessFunction;
  fnp : Pointer;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if (not processMap_.TryGetValuePointer(msg.Name, fnp))
    or (fnp=nil) then
    begin
      TProtocolUtil.Skip(iprot, {TType.}Struct);
      iprot.ReadMessageEnd();
      x := TApplicationException.Create({TApplicationException.TExceptionType.}UnknownMethod, 'Invalid method name: ''' + msg.Name + '''');
      msg := TMessageImpl.Create(msg.Name, {TMessageType.}Exception_, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    //fn:=TProcessFunction(fnp);
    PCardinal(@fn):=fnp;
    fn(msg.SeqID, iprot, oprot,iface_);
  except
    Result := False;
    Exit;
  end;
  Result := True;
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testVoid_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestVoid_args;
  msg: IMessage;
  ret: ITestVoid_result;
begin
  args := TTestVoid_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestVoid_resultImpl.Create;
  miface_.testVoid();
  msg := TMessageImpl.Create('testVoid', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testString_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestString_args;
  msg: IMessage;
  ret: ITestString_result;
begin
  args := TTestString_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestString_resultImpl.Create;
  ret.Success := miface_.testString(args.Thing);
  args.Thing := '';
  msg := TMessageImpl.Create('testString', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testByte_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestByte_args;
  msg: IMessage;
  ret: ITestByte_result;
begin
  args := TTestByte_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestByte_resultImpl.Create;
  ret.Success := miface_.testByte(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testByte', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testI32_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestI32_args;
  msg: IMessage;
  ret: ITestI32_result;
begin
  args := TTestI32_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestI32_resultImpl.Create;
  ret.Success := miface_.testI32(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testI32', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testI64_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestI64_args;
  msg: IMessage;
  ret: ITestI64_result;
begin
  args := TTestI64_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestI64_resultImpl.Create;
  ret.Success := miface_.testI64(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testI64', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testDouble_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestDouble_args;
  msg: IMessage;
  ret: ITestDouble_result;
begin
  args := TTestDouble_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestDouble_resultImpl.Create;
  ret.Success := miface_.testDouble(args.Thing);
  args.Thing := 0.0;
  msg := TMessageImpl.Create('testDouble', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testStruct_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestStruct_args;
  msg: IMessage;
  ret: ITestStruct_result;
begin
  args := TTestStruct_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestStruct_resultImpl.Create;
  ret.Success := miface_.testStruct(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testStruct', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testNest_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestNest_args;
  msg: IMessage;
  ret: ITestNest_result;
begin
  args := TTestNest_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestNest_resultImpl.Create;
  ret.Success := miface_.testNest(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testNest', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMap_args;
  msg: IMessage;
  ret: ITestMap_result;
begin
  args := TTestMap_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMap_resultImpl.Create;
  ret.Success := miface_.testMap(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testMap', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testStringMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestStringMap_args;
  msg: IMessage;
  ret: ITestStringMap_result;
begin
  args := TTestStringMap_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestStringMap_resultImpl.Create;
  ret.Success := miface_.testStringMap(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testStringMap', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testSet_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestSet_args;
  msg: IMessage;
  ret: ITestSet_result;
begin
  args := TTestSet_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestSet_resultImpl.Create;
  ret.Success := miface_.testSet(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testSet', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testList_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestList_args;
  msg: IMessage;
  ret: ITestList_result;
begin
  args := TTestList_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestList_resultImpl.Create;
  ret.Success := miface_.testList(args.Thing);
  args.Thing := nil;
  msg := TMessageImpl.Create('testList', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testEnum_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestEnum_args;
  msg: IMessage;
  ret: ITestEnum_result;
begin
  args := TTestEnum_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestEnum_resultImpl.Create;
  ret.Success := miface_.testEnum(args.Thing);
  args.Thing := TNumberz(0);
  msg := TMessageImpl.Create('testEnum', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testTypedef_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestTypedef_args;
  msg: IMessage;
  ret: ITestTypedef_result;
begin
  args := TTestTypedef_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestTypedef_resultImpl.Create;
  ret.Success := miface_.testTypedef(args.Thing);
  args.Thing := 0;
  msg := TMessageImpl.Create('testTypedef', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMapMap_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMapMap_args;
  msg: IMessage;
  ret: ITestMapMap_result;
begin
  args := TTestMapMap_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMapMap_resultImpl.Create;
  ret.Success := miface_.testMapMap(args.Hello);
  args.Hello := 0;
  msg := TMessageImpl.Create('testMapMap', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testInsanity_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestInsanity_args;
  msg: IMessage;
  ret: ITestInsanity_result;
begin
  args := TTestInsanity_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestInsanity_resultImpl.Create;
  ret.Success := miface_.testInsanity(args.Argument);
  args.Argument := nil;
  msg := TMessageImpl.Create('testInsanity', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMulti_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMulti_args;
  msg: IMessage;
  ret: ITestMulti_result;
begin
  args := TTestMulti_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMulti_resultImpl.Create;
  ret.Success := miface_.testMulti(args.Arg0, args.Arg1, args.Arg2, args.Arg3, args.Arg4, args.Arg5);
  args.Arg0 := 0;
  args.Arg1 := 0;
  args.Arg2 := 0;
  args.Arg3 := nil;
  args.Arg4 := TNumberz(0);
  args.Arg5 := 0;
  msg := TMessageImpl.Create('testMulti', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestException_args;
  msg: IMessage;
  ret: ITestException_result;
begin
  args := TTestException_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestException_resultImpl.Create;
  try
    miface_.testException(args.Arg);
    args.Arg := '';
  except
    on E: TXception do
    begin
      ret.Err1 := E.XceptionFactory;
    end;
  end;
  msg := TMessageImpl.Create('testException', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TThriftTest.TProcessorImpl.testMultiException_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestMultiException_args;
  msg: IMessage;
  ret: ITestMultiException_result;
begin
  args := TTestMultiException_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TTestMultiException_resultImpl.Create;
  try
    ret.Success := miface_.testMultiException(args.Arg0, args.Arg1);
    args.Arg0 := '';
    args.Arg1 := '';
  except
    on E: TXception do
    begin
      ret.Err1 := E.XceptionFactory;
    end;
    on E: TXception2 do
    begin
      ret.Err2 := E.Xception2Factory;
    end;
  end;
  msg := TMessageImpl.Create('testMultiException', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// one way processor
procedure TThriftTest.TProcessorImpl.testOneway_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: ITestOneway_args;
begin
  args := TTestOneway_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  miface_.testOneway(args.SecondsToSleep);
  args.SecondsToSleep := 0;
end;

constructor TThriftTest.TTestVoid_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestVoid_argsImpl.Destroy;
begin
  inherited;
end;

procedure TThriftTest.TTestVoid_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestVoid_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('testVoid_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestVoid_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestVoid_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestVoid_resultImpl.Destroy;
begin
  inherited;
end;

procedure TThriftTest.TTestVoid_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestVoid_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('testVoid_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestVoid_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestString_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestString_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestString_argsImpl.GetThing: string;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestString_argsImpl.SetThing( const Value: string);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestString_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestString_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Thing := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestString_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testString_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestString_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestString_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestString_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestString_resultImpl.GetSuccess: string;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestString_resultImpl.SetSuccess( const Value: string);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestString_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestString_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Success := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestString_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testString_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}String_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestString_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestByte_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestByte_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestByte_argsImpl.GetThing: ShortInt;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestByte_argsImpl.SetThing( const Value: ShortInt);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestByte_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestByte_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Thing := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestByte_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testByte_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestByte_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestByte_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestByte_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestByte_resultImpl.GetSuccess: ShortInt;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestByte_resultImpl.SetSuccess( const Value: ShortInt);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestByte_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestByte_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Success := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestByte_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testByte_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestByte_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI32_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI32_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI32_argsImpl.GetThing: Integer;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestI32_argsImpl.SetThing( const Value: Integer);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestI32_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestI32_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Thing := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI32_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI32_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI32_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI32_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI32_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI32_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestI32_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestI32_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestI32_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI32_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI32_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI32_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI64_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI64_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI64_argsImpl.GetThing: Int64;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestI64_argsImpl.SetThing( const Value: Int64);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestI64_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestI64_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI64_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI64_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI64_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestI64_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestI64_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestI64_resultImpl.GetSuccess: Int64;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestI64_resultImpl.SetSuccess( const Value: Int64);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestI64_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestI64_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Success := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestI64_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testI64_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I64;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestI64_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestDouble_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestDouble_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestDouble_argsImpl.GetThing: Double;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestDouble_argsImpl.SetThing( const Value: Double);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestDouble_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestDouble_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Double_) then
          begin
            Thing := iprot.ReadDouble();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestDouble_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testDouble_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Double_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteDouble(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestDouble_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestDouble_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestDouble_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestDouble_resultImpl.GetSuccess: Double;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestDouble_resultImpl.SetSuccess( const Value: Double);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestDouble_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestDouble_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Double_) then
          begin
            Success := iprot.ReadDouble();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestDouble_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testDouble_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Double_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteDouble(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestDouble_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStruct_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStruct_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStruct_argsImpl.GetThing: IXtruct;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestStruct_argsImpl.SetThing( const Value: IXtruct);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestStruct_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestStruct_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Thing := TXtructImpl.Create;
            Thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStruct_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testStruct_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStruct_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    if (Thing = nil) then sb.Append('<null>') else sb.Append(Thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStruct_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStruct_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStruct_resultImpl.GetSuccess: IXtruct;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestStruct_resultImpl.SetSuccess( const Value: IXtruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestStruct_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestStruct_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtructImpl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStruct_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testStruct_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStruct_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestNest_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestNest_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestNest_argsImpl.GetThing: IXtruct2;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestNest_argsImpl.SetThing( const Value: IXtruct2);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestNest_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestNest_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Thing := TXtruct2Impl.Create;
            Thing.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestNest_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testNest_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Thing.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestNest_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    if (Thing = nil) then sb.Append('<null>') else sb.Append(Thing.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestNest_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestNest_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestNest_resultImpl.GetSuccess: IXtruct2;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestNest_resultImpl.SetSuccess( const Value: IXtruct2);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestNest_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestNest_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtruct2Impl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestNest_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testNest_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestNest_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMap_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMap_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMap_argsImpl.GetThing: IThriftDictionary_V_V;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestMap_argsImpl.SetThing( const Value: IThriftDictionary_V_V);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestMap_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestMap_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map178: IMap;
  _i179: Integer;
  _key180: Integer;
  _val181: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Thing := TThriftDictionary_V_VImpl.Create;
            _map178 := iprot.ReadMapBegin();
            for _i179 := 0 to _map178.Count - 1 do
            begin
              _key180 := iprot.ReadI32();
              _val181 := iprot.ReadI32();
              Thing.AddOrSetValue( _key180, _val181);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMap_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map182 : IMap;
  _iter183: Integer;
begin
  struc := TStructImpl.Create('testMap_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map182 := TMapImpl.Create( {TType.}I32, {TType.}I32, Thing.Count);
    oprot.WriteMapBegin( map182);
    for _iter183 in Thing.Keys do
    begin
      oprot.WriteI32(_iter183);
      oprot.WriteI32(Thing[_iter183]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMap_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMap_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMap_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMap_resultImpl.GetSuccess: IThriftDictionary_V_V;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMap_resultImpl.SetSuccess( const Value: IThriftDictionary_V_V);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMap_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestMap_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map184: IMap;
  _i185: Integer;
  _key186: Integer;
  _val187: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionary_V_VImpl.Create;
            _map184 := iprot.ReadMapBegin();
            for _i185 := 0 to _map184.Count - 1 do
            begin
              _key186 := iprot.ReadI32();
              _val187 := iprot.ReadI32();
              Success.AddOrSetValue( _key186, _val187);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMap_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map188 : IMap;
  _iter189: Integer;
begin
  struc := TStructImpl.Create('testMap_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map188 := TMapImpl.Create( {TType.}I32, {TType.}I32, Success.Count);
    oprot.WriteMapBegin( map188);
    for _iter189 in Success.Keys do
    begin
      oprot.WriteI32(_iter189);
      oprot.WriteI32(Success[_iter189]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMap_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStringMap_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStringMap_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStringMap_argsImpl.GetThing: IThriftDictionary_V_V;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestStringMap_argsImpl.SetThing( const Value: IThriftDictionary_V_V);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestStringMap_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestStringMap_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map190: IMap;
  _i191: Integer;
  _key192: string;
  _val193: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Thing := TThriftDictionary_V_VImpl.Create;
            _map190 := iprot.ReadMapBegin();
            for _i191 := 0 to _map190.Count - 1 do
            begin
              _key192 := iprot.ReadString();
              _val193 := iprot.ReadString();
              Thing.AddOrSetValue( _key192, _val193);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStringMap_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map194 : IMap;
  _iter195: string;
begin
  struc := TStructImpl.Create('testStringMap_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Map;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    map194 := TMapImpl.Create( {TType.}String_, {TType.}String_, Thing.Count);
    oprot.WriteMapBegin( map194);
    for _iter195 in Thing.Keys do
    begin
      oprot.WriteString(_iter195);
      oprot.WriteString(Thing[_iter195]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStringMap_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestStringMap_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestStringMap_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestStringMap_resultImpl.GetSuccess: IThriftDictionary_V_V;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestStringMap_resultImpl.SetSuccess( const Value: IThriftDictionary_V_V);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestStringMap_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestStringMap_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map196: IMap;
  _i197: Integer;
  _key198: string;
  _val199: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionary_V_VImpl.Create;
            _map196 := iprot.ReadMapBegin();
            for _i197 := 0 to _map196.Count - 1 do
            begin
              _key198 := iprot.ReadString();
              _val199 := iprot.ReadString();
              Success.AddOrSetValue( _key198, _val199);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestStringMap_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map200 : IMap;
  _iter201: string;
begin
  struc := TStructImpl.Create('testStringMap_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map200 := TMapImpl.Create( {TType.}String_, {TType.}String_, Success.Count);
    oprot.WriteMapBegin( map200);
    for _iter201 in Success.Keys do
    begin
      oprot.WriteString(_iter201);
      oprot.WriteString(Success[_iter201]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestStringMap_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestSet_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestSet_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestSet_argsImpl.GetThing: IHashSet_V;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestSet_argsImpl.SetThing( const Value: IHashSet_V);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestSet_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestSet_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set202: ISet;
  _i203: Integer;
  _elem204: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Thing := THashSet_VImpl.Create;
            _set202 := iprot.ReadSetBegin();
            for _i203 := 0 to _set202.Count - 1 do
            begin
              _elem204 := iprot.ReadI32();
              Thing.Add(_elem204);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestSet_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_205 : ISet;
  _iter206: Integer;
begin
  struc := TStructImpl.Create('testSet_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}Set_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    set_205 := TSetImpl.Create({TType.}I32, Thing.Count);
    oprot.WriteSetBegin( set_205);
    for _iter206 in Thing do
    begin
      oprot.WriteI32(_iter206);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestSet_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestSet_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestSet_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestSet_resultImpl.GetSuccess: IHashSet_V;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestSet_resultImpl.SetSuccess( const Value: IHashSet_V);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestSet_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestSet_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _set207: ISet;
  _i208: Integer;
  _elem209: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Set_) then
          begin
            Success := THashSet_VImpl.Create;
            _set207 := iprot.ReadSetBegin();
            for _i208 := 0 to _set207.Count - 1 do
            begin
              _elem209 := iprot.ReadI32();
              Success.Add(_elem209);
            end;
            iprot.ReadSetEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestSet_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  set_210 : ISet;
  _iter211: Integer;
begin
  struc := TStructImpl.Create('testSet_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Set_;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    set_210 := TSetImpl.Create({TType.}I32, Success.Count);
    oprot.WriteSetBegin( set_210);
    for _iter211 in Success do
    begin
      oprot.WriteI32(_iter211);
    end;
    oprot.WriteSetEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestSet_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestList_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestList_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestList_argsImpl.GetThing: IThriftList_V;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestList_argsImpl.SetThing( const Value: IThriftList_V);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestList_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestList_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list212: IList;
  _i213: Integer;
  _elem214: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Thing := TThriftList_VImpl.Create;
            _list212 := iprot.ReadListBegin();
            for _i213 := 0 to _list212.Count - 1 do
            begin
              _elem214 := iprot.ReadI32();
              Thing.Add(_elem214);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestList_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_215 : IList;
  _iter216: Integer;
begin
  struc := TStructImpl.Create('testList_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Thing <> nil) and __isset_Thing then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}List;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    list_215 := TListImpl.Create({TType.}I32, Thing.Count);
    oprot.WriteListBegin( list_215);
    for _iter216 in Thing do
    begin
      oprot.WriteI32(_iter216);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestList_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestList_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestList_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestList_resultImpl.GetSuccess: IThriftList_V;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestList_resultImpl.SetSuccess( const Value: IThriftList_V);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestList_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestList_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _list217: IList;
  _i218: Integer;
  _elem219: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}List) then
          begin
            Success := TThriftList_VImpl.Create;
            _list217 := iprot.ReadListBegin();
            for _i218 := 0 to _list217.Count - 1 do
            begin
              _elem219 := iprot.ReadI32();
              Success.Add(_elem219);
            end;
            iprot.ReadListEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestList_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  list_220 : IList;
  _iter221: Integer;
begin
  struc := TStructImpl.Create('testList_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}List;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    list_220 := TListImpl.Create({TType.}I32, Success.Count);
    oprot.WriteListBegin( list_220);
    for _iter221 in Success do
    begin
      oprot.WriteI32(_iter221);
    end;
    oprot.WriteListEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestList_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestEnum_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestEnum_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestEnum_argsImpl.GetThing: TNumberz;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestEnum_argsImpl.SetThing( const Value: TNumberz);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestEnum_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestEnum_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Thing := TNumberz(iprot.ReadI32());
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestEnum_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testEnum_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Integer(Thing));
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestEnum_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Integer(Thing));
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestEnum_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestEnum_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestEnum_resultImpl.GetSuccess: TNumberz;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestEnum_resultImpl.SetSuccess( const Value: TNumberz);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestEnum_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestEnum_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Success := TNumberz(iprot.ReadI32());
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestEnum_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testEnum_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Integer(Success));
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestEnum_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Integer(Success));
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestTypedef_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestTypedef_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestTypedef_argsImpl.GetThing: TUserId;
begin
  Result := FThing;
end;

procedure TThriftTest.TTestTypedef_argsImpl.SetThing( const Value: TUserId);
begin
  F__isset_Thing := True;
  FThing := Value;
end;

function TThriftTest.TTestTypedef_argsImpl.Get__isset_Thing: Boolean;
begin
  Result := F__isset_Thing;
end;

procedure TThriftTest.TTestTypedef_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Thing := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestTypedef_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testTypedef_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Thing) then
  begin
    field_.Name := 'thing';
    field_.Type_  := {TType.}I64;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Thing);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestTypedef_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Thing: ');
    sb.Append(Thing);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestTypedef_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestTypedef_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestTypedef_resultImpl.GetSuccess: TUserId;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestTypedef_resultImpl.SetSuccess( const Value: TUserId);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestTypedef_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestTypedef_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Success := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestTypedef_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testTypedef_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Success) then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}I64;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestTypedef_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMapMap_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMapMap_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMapMap_argsImpl.GetHello: Integer;
begin
  Result := FHello;
end;

procedure TThriftTest.TTestMapMap_argsImpl.SetHello( const Value: Integer);
begin
  F__isset_Hello := True;
  FHello := Value;
end;

function TThriftTest.TTestMapMap_argsImpl.Get__isset_Hello: Boolean;
begin
  Result := F__isset_Hello;
end;

procedure TThriftTest.TTestMapMap_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Hello := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMapMap_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMapMap_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Hello) then
  begin
    field_.Name := 'hello';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Hello);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMapMap_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Hello: ');
    sb.Append(Hello);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMapMap_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMapMap_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMapMap_resultImpl.GetSuccess: IThriftDictionary_V_V;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMapMap_resultImpl.SetSuccess( const Value: IThriftDictionary_V_V);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMapMap_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestMapMap_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map222: IMap;
  _i223: Integer;
  _key224: Integer;
  _val225: IThriftDictionary_V_V;
  _map226: IMap;
  _i227: Integer;
  _key228: Integer;
  _val229: Integer;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionary_V_VImpl.Create;
            _map222 := iprot.ReadMapBegin();
            for _i223 := 0 to _map222.Count - 1 do
            begin
              _key224 := iprot.ReadI32();
              _val225 := TThriftDictionary_V_VImpl.Create;
              _map226 := iprot.ReadMapBegin();
              for _i227 := 0 to _map226.Count - 1 do
              begin
                _key228 := iprot.ReadI32();
                _val229 := iprot.ReadI32();
                _val225.AddOrSetValue( _key228, _val229);
              end;
              iprot.ReadMapEnd();
              Success.AddOrSetValue( _key224, _val225);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMapMap_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map230 : IMap;
  _iter231: Integer;
  map232 : IMap;
  _iter233: Integer;
begin
  struc := TStructImpl.Create('testMapMap_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map230 := TMapImpl.Create( {TType.}I32, {TType.}Map, Success.Count);
    oprot.WriteMapBegin( map230);
    for _iter231 in Success.Keys do
    begin
      oprot.WriteI32(_iter231);
      map232 := TMapImpl.Create( {TType.}I32, {TType.}I32, Success[_iter231].Count);
      oprot.WriteMapBegin( map232);
      for _iter233 in Success[_iter231].Keys do
      begin
        oprot.WriteI32(_iter233);
        oprot.WriteI32(Success[_iter231][_iter233]);
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMapMap_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestInsanity_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestInsanity_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestInsanity_argsImpl.GetArgument: IInsanity;
begin
  Result := FArgument;
end;

procedure TThriftTest.TTestInsanity_argsImpl.SetArgument( const Value: IInsanity);
begin
  F__isset_Argument := True;
  FArgument := Value;
end;

function TThriftTest.TTestInsanity_argsImpl.Get__isset_Argument: Boolean;
begin
  Result := F__isset_Argument;
end;

procedure TThriftTest.TTestInsanity_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Argument := TInsanityImpl.Create;
            Argument.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestInsanity_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testInsanity_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Argument <> nil) and __isset_Argument then
  begin
    field_.Name := 'argument';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Argument.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestInsanity_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Argument: ');
    if (Argument = nil) then sb.Append('<null>') else sb.Append(Argument.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestInsanity_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestInsanity_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestInsanity_resultImpl.GetSuccess: IThriftDictionary_V_V;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestInsanity_resultImpl.SetSuccess( const Value: IThriftDictionary_V_V);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestInsanity_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestInsanity_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map234: IMap;
  _i235: Integer;
  _key236: TUserId;
  _val237: IThriftDictionary_V_V;
  _map238: IMap;
  _i239: Integer;
  _key240: TNumberz;
  _val241: IInsanity;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Success := TThriftDictionary_V_VImpl.Create;
            _map234 := iprot.ReadMapBegin();
            for _i235 := 0 to _map234.Count - 1 do
            begin
              _key236 := iprot.ReadI64();
              _val237 := TThriftDictionary_V_VImpl.Create;
              _map238 := iprot.ReadMapBegin();
              for _i239 := 0 to _map238.Count - 1 do
              begin
                _key240 := TNumberz(iprot.ReadI32());
                _val241 := TInsanityImpl.Create;
                _val241.Read(iprot);
                _val237.AddOrSetValue( _key240, _val241);
              end;
              iprot.ReadMapEnd();
              Success.AddOrSetValue( _key236, _val237);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestInsanity_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map242 : IMap;
  _iter243: TUserId;
  map244 : IMap;
  _iter245: TNumberz;
begin
  struc := TStructImpl.Create('testInsanity_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Map;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    map242 := TMapImpl.Create( {TType.}I64, {TType.}Map, Success.Count);
    oprot.WriteMapBegin( map242);
    for _iter243 in Success.Keys do
    begin
      oprot.WriteI64(_iter243);
      map244 := TMapImpl.Create( {TType.}I32, {TType.}Struct, Success[_iter243].Count);
      oprot.WriteMapBegin( map244);
      for _iter245 in Success[_iter243].Keys do
      begin
        oprot.WriteI32(Integer(_iter245));
        Success[_iter243][_iter245].Write(oprot);
      end;
      oprot.WriteMapEnd();
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestInsanity_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    sb.Append(Success);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMulti_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMulti_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg0: ShortInt;
begin
  Result := FArg0;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg0( const Value: ShortInt);
begin
  F__isset_Arg0 := True;
  FArg0 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg0: Boolean;
begin
  Result := F__isset_Arg0;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg1: Integer;
begin
  Result := FArg1;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg1( const Value: Integer);
begin
  F__isset_Arg1 := True;
  FArg1 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg1: Boolean;
begin
  Result := F__isset_Arg1;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg2: Int64;
begin
  Result := FArg2;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg2( const Value: Int64);
begin
  F__isset_Arg2 := True;
  FArg2 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg2: Boolean;
begin
  Result := F__isset_Arg2;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg3: IThriftDictionary_V_V;
begin
  Result := FArg3;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg3( const Value: IThriftDictionary_V_V);
begin
  F__isset_Arg3 := True;
  FArg3 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg3: Boolean;
begin
  Result := F__isset_Arg3;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg4: TNumberz;
begin
  Result := FArg4;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg4( const Value: TNumberz);
begin
  F__isset_Arg4 := True;
  FArg4 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg4: Boolean;
begin
  Result := F__isset_Arg4;
end;

function TThriftTest.TTestMulti_argsImpl.GetArg5: TUserId;
begin
  Result := FArg5;
end;

procedure TThriftTest.TTestMulti_argsImpl.SetArg5( const Value: TUserId);
begin
  F__isset_Arg5 := True;
  FArg5 := Value;
end;

function TThriftTest.TTestMulti_argsImpl.Get__isset_Arg5: Boolean;
begin
  Result := F__isset_Arg5;
end;

procedure TThriftTest.TTestMulti_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;
  _map246: IMap;
  _i247: Integer;
  _key248: SmallInt;
  _val249: string;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Byte_) then
          begin
            Arg0 := iprot.ReadByte();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Arg1 := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Arg2 := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = {TType.}Map) then
          begin
            Arg3 := TThriftDictionary_V_VImpl.Create;
            _map246 := iprot.ReadMapBegin();
            for _i247 := 0 to _map246.Count - 1 do
            begin
              _key248 := iprot.ReadI16();
              _val249 := iprot.ReadString();
              Arg3.AddOrSetValue( _key248, _val249);
            end;
            iprot.ReadMapEnd();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        5: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            Arg4 := TNumberz(iprot.ReadI32());
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        6: begin
          if (field_.Type_ = {TType.}I64) then
          begin
            Arg5 := iprot.ReadI64();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMulti_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
  map250 : IMap;
  _iter251: SmallInt;
begin
  struc := TStructImpl.Create('testMulti_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg0) then
  begin
    field_.Name := 'arg0';
    field_.Type_  := {TType.}Byte_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteByte(Arg0);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg1) then
  begin
    field_.Name := 'arg1';
    field_.Type_  := {TType.}I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Arg1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg2) then
  begin
    field_.Name := 'arg2';
    field_.Type_  := {TType.}I64;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Arg2);
    oprot.WriteFieldEnd();
  end;
  if (Arg3 <> nil) and __isset_Arg3 then
  begin
    field_.Name := 'arg3';
    field_.Type_  := {TType.}Map;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    map250 := TMapImpl.Create( {TType.}I16, {TType.}String_, Arg3.Count);
    oprot.WriteMapBegin( map250);
    for _iter251 in Arg3.Keys do
    begin
      oprot.WriteI16(_iter251);
      oprot.WriteString(Arg3[_iter251]);
    end;
    oprot.WriteMapEnd();
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg4) then
  begin
    field_.Name := 'arg4';
    field_.Type_  := {TType.}I32;
    field_.ID := 5;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Integer(Arg4));
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg5) then
  begin
    field_.Name := 'arg5';
    field_.Type_  := {TType.}I64;
    field_.ID := 6;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI64(Arg5);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMulti_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg0: ');
    sb.Append(Arg0);
    sb.Append(',Arg1: ');
    sb.Append(Arg1);
    sb.Append(',Arg2: ');
    sb.Append(Arg2);
    sb.Append(',Arg3: ');
    sb.Append(Arg3);
    sb.Append(',Arg4: ');
    sb.Append(Integer(Arg4));
    sb.Append(',Arg5: ');
    sb.Append(Arg5);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMulti_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMulti_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMulti_resultImpl.GetSuccess: IXtruct;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMulti_resultImpl.SetSuccess( const Value: IXtruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMulti_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TThriftTest.TTestMulti_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtructImpl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMulti_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMulti_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMulti_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestException_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestException_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestException_argsImpl.GetArg: string;
begin
  Result := FArg;
end;

procedure TThriftTest.TTestException_argsImpl.SetArg( const Value: string);
begin
  F__isset_Arg := True;
  FArg := Value;
end;

function TThriftTest.TTestException_argsImpl.Get__isset_Arg: Boolean;
begin
  Result := F__isset_Arg;
end;

procedure TThriftTest.TTestException_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Arg := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestException_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testException_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg) then
  begin
    field_.Name := 'arg';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Arg);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestException_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg: ');
    sb.Append(Arg);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestException_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestException_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestException_resultImpl.GetErr1: TXception.IXceptionFactory;
begin
  Result := FErr1;
end;

procedure TThriftTest.TTestException_resultImpl.SetErr1( const Value: TXception.IXceptionFactory);
begin
  F__isset_Err1 := True;
  FErr1 := Value;
end;

function TThriftTest.TTestException_resultImpl.Get__isset_Err1: Boolean;
begin
  Result := F__isset_Err1;
end;

procedure TThriftTest.TTestException_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Err1 := TXception.TXceptionFactoryImpl.Create;
            Err1.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestException_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testException_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Err1 <> nil) and __isset_Err1 then
  begin
    field_.Name := 'err1';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Err1.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestException_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Err1: ');
    if (Err1 = nil) then sb.Append('<null>') else sb.Append(Err1.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMultiException_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMultiException_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMultiException_argsImpl.GetArg0: string;
begin
  Result := FArg0;
end;

procedure TThriftTest.TTestMultiException_argsImpl.SetArg0( const Value: string);
begin
  F__isset_Arg0 := True;
  FArg0 := Value;
end;

function TThriftTest.TTestMultiException_argsImpl.Get__isset_Arg0: Boolean;
begin
  Result := F__isset_Arg0;
end;

function TThriftTest.TTestMultiException_argsImpl.GetArg1: string;
begin
  Result := FArg1;
end;

procedure TThriftTest.TTestMultiException_argsImpl.SetArg1( const Value: string);
begin
  F__isset_Arg1 := True;
  FArg1 := Value;
end;

function TThriftTest.TTestMultiException_argsImpl.Get__isset_Arg1: Boolean;
begin
  Result := F__isset_Arg1;
end;

procedure TThriftTest.TTestMultiException_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Arg0 := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}String_) then
          begin
            Arg1 := iprot.ReadString();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMultiException_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMultiException_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_Arg0) then
  begin
    field_.Name := 'arg0';
    field_.Type_  := {TType.}String_;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Arg0);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Arg1) then
  begin
    field_.Name := 'arg1';
    field_.Type_  := {TType.}String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Arg1);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMultiException_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Arg0: ');
    sb.Append(Arg0);
    sb.Append(',Arg1: ');
    sb.Append(Arg1);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestMultiException_resultImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestMultiException_resultImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestMultiException_resultImpl.GetSuccess: IXtruct;
begin
  Result := FSuccess;
end;

procedure TThriftTest.TTestMultiException_resultImpl.SetSuccess( const Value: IXtruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TThriftTest.TTestMultiException_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

function TThriftTest.TTestMultiException_resultImpl.GetErr1: TXception.IXceptionFactory;
begin
  Result := FErr1;
end;

procedure TThriftTest.TTestMultiException_resultImpl.SetErr1( const Value: TXception.IXceptionFactory);
begin
  F__isset_Err1 := True;
  FErr1 := Value;
end;

function TThriftTest.TTestMultiException_resultImpl.Get__isset_Err1: Boolean;
begin
  Result := F__isset_Err1;
end;

function TThriftTest.TTestMultiException_resultImpl.GetErr2: TXception2.IXception2Factory;
begin
  Result := FErr2;
end;

procedure TThriftTest.TTestMultiException_resultImpl.SetErr2( const Value: TXception2.IXception2Factory);
begin
  F__isset_Err2 := True;
  FErr2 := Value;
end;

function TThriftTest.TTestMultiException_resultImpl.Get__isset_Err2: Boolean;
begin
  Result := F__isset_Err2;
end;

procedure TThriftTest.TTestMultiException_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Success := TXtructImpl.Create;
            Success.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Err1 := TXception.TXceptionFactoryImpl.Create;
            Err1.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = {TType.}Struct) then
          begin
            Err2 := TXception2.TXception2FactoryImpl.Create;
            Err2.Read(iprot);
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestMultiException_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testMultiException_result');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (Success <> nil) and __isset_Success then
  begin
    field_.Name := 'Success';
    field_.Type_  := {TType.}Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Err1 <> nil) and __isset_Err1 then
  begin
    field_.Name := 'err1';
    field_.Type_  := {TType.}Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Err1.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  if (Err2 <> nil) and __isset_Err2 then
  begin
    field_.Name := 'err2';
    field_.Type_  := {TType.}Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Err2.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestMultiException_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('Success: ');
    if (Success = nil) then sb.Append('<null>') else sb.Append(Success.ToString());
    sb.Append(',Err1: ');
    if (Err1 = nil) then sb.Append('<null>') else sb.Append(Err1.ToString());
    sb.Append(',Err2: ');
    if (Err2 = nil) then sb.Append('<null>') else sb.Append(Err2.ToString());
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TThriftTest.TTestOneway_argsImpl.Create;
begin
  inherited;
end;

destructor TThriftTest.TTestOneway_argsImpl.Destroy;
begin
  inherited;
end;

function TThriftTest.TTestOneway_argsImpl.GetSecondsToSleep: Integer;
begin
  Result := FSecondsToSleep;
end;

procedure TThriftTest.TTestOneway_argsImpl.SetSecondsToSleep( const Value: Integer);
begin
  F__isset_SecondsToSleep := True;
  FSecondsToSleep := Value;
end;

function TThriftTest.TTestOneway_argsImpl.Get__isset_SecondsToSleep: Boolean;
begin
  Result := F__isset_SecondsToSleep;
end;

procedure TThriftTest.TTestOneway_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = {TType.}I32) then
          begin
            SecondsToSleep := iprot.ReadI32();
          end else
          begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TThriftTest.TTestOneway_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
  field_ : IField;
begin
  struc := TStructImpl.Create('testOneway_args');
  oprot.WriteStructBegin(struc);
  field_ := TFieldImpl.Create;
  if (__isset_SecondsToSleep) then
  begin
    field_.Name := 'secondsToSleep';
    field_.Type_  := {TType.}I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(SecondsToSleep);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TThriftTest.TTestOneway_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append('SecondsToSleep: ');
    sb.Append(SecondsToSleep);
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSecondService.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TSecondService.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  iprot_ := iprot;
  oprot_ := oprot;
end;

procedure TSecondService.TClient.blahBlah();
begin
  send_blahBlah();
  recv_blahBlah();
end;

procedure TSecondService.TClient.send_blahBlah();
var
  args : IBlahBlah_args;
  msg : IMessage;
begin
  seqid_ := seqid_ + 1;
  msg := TMessageImpl.Create('blahBlah', {TMessageType.}Call, seqid_);
  oprot_.WriteMessageBegin( msg );
  args := TBlahBlah_argsImpl.Create();
  args.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TSecondService.TClient.recv_blahBlah();
var
  msg : IMessage;
  x : TApplicationException;
  ret : IBlahBlah_result;
begin
  msg := iprot_.ReadMessageBegin();
  if (msg.Type_ = {TMessageType.}Exception_) then
  begin
    x := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise x;
  end;
  ret := TBlahBlah_resultImpl.Create();
  ret.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

constructor TSecondService.TProcessorImpl.Create( iface_: Iface );
var
tmpmethod:TProcessFunction;
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionary_V_VImpl{<string, TProcessFunction>}.Create;
  //processMap_.AddOrSetValue( 'blahBlah', blahBlah_Process);
  tmpmethod:=Self.blahBlah_Process;
  processMap_.AddOrSetValue( 'blahBlah',Pointer(@tmpmethod));
end;

destructor TSecondService.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TSecondService.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol): Boolean;
var
  msg : IMessage;
  fn : TProcessFunction;
  fnp : Pointer;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if (not processMap_.TryGetValuePointer(msg.Name, fnp))
    or (fnp=nil) then
    begin
      TProtocolUtil.Skip(iprot, {TType.}Struct);
      iprot.ReadMessageEnd();
      x := TApplicationException.Create({TApplicationException.TExceptionType.}UnknownMethod, 'Invalid method name: ''' + msg.Name + '''');
      msg := TMessageImpl.Create(msg.Name, {TMessageType.}Exception_, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    //fn:=TProcessFunction(fnp);
    PCardinal(@fn):=fnp;
    fn(msg.SeqID, iprot, oprot,iface_);
  except
    Result := False;
    Exit;
  end;
  Result := True;
end;

// both way processor
procedure TSecondService.TProcessorImpl.blahBlah_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol;miface_: Iface);
var
  args: IBlahBlah_args;
  msg: IMessage;
  ret: IBlahBlah_result;
begin
  args := TBlahBlah_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TBlahBlah_resultImpl.Create;
  miface_.blahBlah();
  msg := TMessageImpl.Create('blahBlah', {TMessageType.}Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

constructor TSecondService.TBlahBlah_argsImpl.Create;
begin
  inherited;
end;

destructor TSecondService.TBlahBlah_argsImpl.Destroy;
begin
  inherited;
end;

procedure TSecondService.TBlahBlah_argsImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSecondService.TBlahBlah_argsImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('blahBlah_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSecondService.TBlahBlah_argsImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

constructor TSecondService.TBlahBlah_resultImpl.Create;
begin
  inherited;
end;

destructor TSecondService.TBlahBlah_resultImpl.Destroy;
begin
  inherited;
end;

procedure TSecondService.TBlahBlah_resultImpl.Read( const iprot: IProtocol);
var
  field_ : IField;
  struc : IStruct;

begin
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = {TType.}Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSecondService.TBlahBlah_resultImpl.Write( const oprot: IProtocol);
var
  struc : IStruct;
begin
  struc := TStructImpl.Create('blahBlah_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSecondService.TBlahBlah_resultImpl.ToString: string;
var
  sb : TThriftStringBuilder;
begin
  sb := TThriftStringBuilder.Create('(');
  try
    sb.Append(')');
    Result := sb.ToString;
  finally
    sb.Free;
  end;
end;

//{$IF CompilerVersion >= 21.0}
{$IFDEF CompilerVersion_g21}
class constructor TConstants.Create;
begin
  FMyNumberz := TNumberz.ONE;
end;

class destructor TConstants.Destroy;
begin
  inherited;
end;
{$ELSE}
procedure TConstants_Initialize;
begin
  TConstants.FMyNumberz := TNumberz.ONE;
end;

procedure TConstants_Finalize;
begin
end;
{$ENDIF}

//{$IFEND}


initialization
//{$IF CompilerVersion < 21.0}
{$IFDEF CompilerVersion_l21}
  TConstants_Initialize;
{$ENDIF}
//{$IFEND}

finalization
//{$IF CompilerVersion < 21.0}
{$IFDEF CompilerVersion_l21}
  TConstants_Finalize;
{$ENDIF}
//{$IFEND}


end.
